<<<<<<< HEAD
<<<<<<< HEAD
=======
<<<<<<< HEAD
ext <- raster::extent(sf::st_bbox(AOI_prj))  # Conversion des limites en format `extent
# Spécification de la résolution en mètres (5 km ici)
res <- 5000
# Définir un système de coordonnées pour le raster
rast_crs <- CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs")
raster_template <- raster::raster(ext=ext, resolution=res, crs=rast_crs)
# Rasteriser les données : calculer la somme des événements dans chaque cellule de la grille
Raster <- raster::rasterize(AOI_prj,raster_template,field=1, fun= sum)
# Sauvegarder le raster en format GeoTIFF
raster::writeRaster(Raster, filename = filename, format = "GTiff", overwrite = TRUE)
return(Raster) # Pour retourner l'objet raster
}
AOI_Raster <- Create_raster(AOI_event, "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif/Rasterisation_general.tif")
# Fonction pour créer un raster basé sur les données géolocalisées
Create_raster <- function(datafile, filename ="C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation.tif") {
# Reprojection des données spatiales pour un système de coordonnées en mètres
# EPSG 32629 : UTM Zone 29N, adapté au Mali
AOI_prj <- st_transform(datafile, crs = 32629)
# Définir l'étendue géographique (extent) à partir des limites de l'objet spatial reprojeté
ext <- raster::extent(sf::st_bbox(AOI_prj))  # Conversion des limites en format `extent
# Spécification de la résolution en mètres (5 km ici)
res <- 5000
# Définir un système de coordonnées pour le raster
rast_crs <- CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs")
raster_template <- raster::raster(ext=ext, resolution=res, crs=rast_crs)
# Rasteriser les données : calculer la somme des événements dans chaque cellule de la grille
Raster <- raster::rasterize(AOI_prj,raster_template,field=1, fun= sum)
# Sauvegarder le raster en format GeoTIFF
raster::writeRaster(Raster, filename = filename, format = "GTiff", overwrite = TRUE)
return(Raster) # Pour retourner l'objet raster
}
AOI_Raster <- Create_raster(AOI_event, "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif/Rasterisation_general.tif")
# Fonction pour créer un raster basé sur les données géolocalisées
Create_raster <- function(datafile, filename = "C:/Users/HP/OneDrive/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif") {
# Reprojection des données spatiales pour un système de coordonnées en mètres
# EPSG 32629 : UTM Zone 29N, adapté au Mali
AOI_prj <- st_transform(datafile, crs = 32629)
# Définir l'étendue géographique (extent) à partir des limites de l'objet spatial reprojeté
ext <- raster::extent(sf::st_bbox(AOI_prj))  # Conversion des limites en format `extent`
# Spécification de la résolution en mètres (5 km ici)
res <- 5000
# Définir un système de coordonnées pour le raster
rast_crs <- CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs")
raster_template <- raster::raster(ext = ext, resolution = res, crs = rast_crs)
# Rasteriser les données : calculer la somme des événements dans chaque cellule de la grille
Raster <- raster::rasterize(AOI_prj, raster_template, field = 1, fun = sum, na.rm = TRUE)
# Sauvegarder le raster en format GeoTIFF
raster::writeRaster(Raster, filename = filename, format = "GTiff", overwrite = TRUE)
return(Raster) # Pour retourner l'objet raster
}
# Application de la fonction sur les données des événements
AOI_Raster <- Create_raster(
AOI_event,
"C:/Users/HP/OneDrive/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif"
)
# Fonction pour créer un raster basé sur les données géolocalisées
Create_raster <- function(datafile, filename = "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation.tif") {
# Reprojection des données spatiales pour un système de coordonnées en mètres
# EPSG 32629 : UTM Zone 29N, adapté au Mali
AOI_prj <- st_transform(datafile, crs = 32629)
# Définir l'étendue géographique (extent) à partir des limites de l'objet spatial reprojeté
ext <- raster::extent(sf::st_bbox(AOI_prj))  # Conversion des limites en format `extent`
# Spécification de la résolution en mètres (5 km ici)
res <- 5000
# Définir un système de coordonnées pour le raster
rast_crs <- CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs")
raster_template <- raster::raster(ext = ext, resolution = res, crs = rast_crs)
# Rasteriser les données : calculer la somme des événements dans chaque cellule de la grille
Raster <- raster::rasterize(AOI_prj, raster_template, field = 1, fun = sum, na.rm = TRUE)
# Sauvegarder le raster en format GeoTIFF
raster::writeRaster(Raster, filename = filename, format = "GTiff", overwrite = TRUE)
return(Raster) # Pour retourner l'objet raster
}
# Application de la fonction sur les données des événements
AOI_Raster <- Create_raster(
AOI_event,
"C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif"
)
plot(AOI_Raster)
# Créer et binariser directement en excluant les NA
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) >= 5] <- 1
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) < 5] <- 0
for( i in unique(data$year)){
assign(paste0("data_", i), data[data$year == i,])
assign(paste0("AOI_Raster_", i), Create_raster(AOI_event,  paste0("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_", i, ".tif")))# Création du raster pour chaque année et sauvegarde en fichier GeoTIFF
}
AOI_Raster_binaire <- AOI_Raster_2020
values(AOI_Raster_binaire) <- ifelse(values(AOI_Raster_2020) >= 5, 1, 0) # Les valeurs 1 sont prises si le nombre d'evenements est supérieur à 5
writeRaster(AOI_Raster_binaire, "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_2020_Binaire_EVENEMENTS.tif", format = "GTiff", overwrite = TRUE)
# Créer et binariser directement en excluant les NA
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) >= 5] <- 1
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) < 5] <- 0
pop <- raster("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/SEN/SEN_population_v1_0_gridded.tif")
### Agréger le raster à 5 km en utilisant la somme
fact <- round(5000/100)
pop_5km <- aggregate(pop, fact = fact, fun = sum, na.rm = TRUE)
writeRaster(pop_5km, "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/SEN/SEN_population_v1_0_gridded_5km.tif", format = "GTiff", overwrite = TRUE)
crs(pop_5km) # En degres (CRS=WGS84)
crs(AOI_Raster_binaire) # En metre (UTM zone 29N)
pop_5km_utm <- projectRaster(pop_5km, crs = crs(AOI_Raster_binaire), method = "ngb")
crs(pop_5km_utm) # C'est maintenant en en metre (UTM zone 29N)
res(pop_5km_utm)
res(AOI_Raster_binaire)
pop_resampled <- resample(pop_5km_utm, AOI_Raster_binaire, method = "ngb")
pop_resampled_binary <- calc(pop_resampled, fun = function(x) {
ifelse(x < 50, 0, 1)
})
print(unique(values(pop_resampled_binary)))
dim_AOI <- dim(AOI_Raster_binaire)
dim_pop <- dim(pop_resampled_binary)
print(paste("Dimensions du raster AOI_Raster_binaire : ", paste(dim_AOI, collapse = " x ")))
print(paste("Dimensions du raster pop_5km_binary : ", paste(dim_pop, collapse = " x ")))
print(unique(values(pop_resampled_binary)))
print(unique(values(AOI_Raster_binaire)))
mult_raster <- AOI_Raster_binaire * pop_resampled_binary
summary(values(mult_raster))
shp_region <- st_read("DONNEES_MALI/mli_admbnda_adm1_1m_gov_20211220.shp", quiet= TRUE)
pop_count <- extract(pop_resampled_binary, shp_region, fun = sum, na.rm = TRUE)
print(pop_count)
shp_region <- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles/sen_admbnda_adm0_anat_20240520.shp", quiet= TRUE)
pop_count <- extract(pop_resampled_binary, shp_region, fun = sum, na.rm = TRUE)
print(pop_count)
prod_count <- extract(mult_raster, shp_region, fun = sum, na.rm = TRUE)
print(prod_count)
CDI <- prod_count / pop_count
plot(CDI)
shp_region <- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles/sen_admbnda_adm1_anat_20240520.shp", quiet= TRUE)
pop_count <- extract(pop_resampled_binary, shp_region, fun = sum, na.rm = TRUE)
print(pop_count)
prod_count <- extract(mult_raster, shp_region, fun = sum, na.rm = TRUE)
print(prod_count)
CDI <- prod_count / pop_count
plot(CDI)
data.frame(Admin = shp_region$ADM1_FR, CDI = CDI)
# Joindre les valeurs du CDI à la carte des régions
shp_region$CDI <- CDI
shp_region_utm <- st_transform(shp_region, crs = 32629)
ggplot(data = shp_region_utm) +
geom_sf(aes(fill = CDI), color = "white", size = 0.2) +  # Remplir selon CDI
scale_fill_viridis_c(option = "C", na.value = "gray") +  # Couleur pour les CDI, gérer les NA en mettant le gris
labs(title = "Carte du CDI par Région", fill = "CDI") +
geom_sf_text(aes(label = ADM1_FR), size = 3, color = "black", fontface = "bold") +
annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm")) +
theme_minimal() +
theme(legend.position = "right",
legend.title = element_text(size = 10),
legend.text = element_text(size = 8)) +
guides(fill = guide_colorbar(title = "CDI", title.position = "top", title.hjust = 0.5, barheight = 10))
a <-data.frame(Admin = shp_region$ADM1_FR, CDI = CDI)
View(a)
a_region <-data.frame(Admin = shp_region$ADM1_FR, CDI = CDI)
View(a_region)
shp_region_utm <- st_transform(shp_region, crs = 32629)
ggplot(data = shp_region_utm) +
geom_sf(aes(fill = CDI), color = "white", size = 0.2) +  # Remplir selon CDI
scale_fill_viridis_c(option = "C", na.value = "gray") +  # Couleur pour les CDI, gérer les NA en mettant le gris
labs(title = "Carte du CDI par Région", fill = "CDI") +
geom_sf_text(aes(label = ADM1_FR), size = 3, color = "black", fontface = "bold") +
annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm")) +
theme_minimal() +
theme(legend.position = "right",
legend.title = element_text(size = 10),
legend.text = element_text(size = 8)) +
guides(fill = guide_colorbar(title = "CDI", title.position = "top", title.hjust = 0.5, barheight = 10))
# Charger le package ggspatial
library(ggspatial)
# Visualisation avec ggplot
ggplot(data = shp_region_utm) +
geom_sf(aes(fill = CDI), color = "white", size = 0.2) +  # Remplir selon CDI
scale_fill_viridis_c(option = "C", na.value = "gray") +  # Couleur pour les CDI, gérer les NA en mettant le gris
labs(title = "Carte du CDI par Région", fill = "CDI") +
geom_sf_text(aes(label = ADM1_FR), size = 3, color = "black", fontface = "bold") +
annotation_north_arrow(location = "tl", which_north = "true",
height = unit(1, "cm"), width = unit(1, "cm"),
style = north_arrow_fancy_orienteering) +  # Style de la flèche
theme_minimal() +
theme(legend.position = "right",
legend.title = element_text(size = 10),
legend.text = element_text(size = 8)) +
guides(fill = guide_colorbar(title = "CDI", title.position = "top",
title.hjust = 0.5, barheight = 10))
# Charger les bibliothèques nécessaires
library(leaflet)
library(sf)
library(viridis) # Pour les palettes de couleurs
# Génération d'une palette de couleurs en fonction de la variable CDI
palette_CDI <- colorNumeric(palette = "viridis", domain = shp_region_utm$CDI, na.color = "gray")
# Carte interactive avec Leaflet
leaflet(data = shp_region_utm) %>%
addTiles() %>%  # Ajouter une couche de fond
addPolygons(
fillColor = ~palette_CDI(CDI),  # Couleur de remplissage en fonction de CDI
weight = 1,  # Bordure des régions
color = "white",  # Couleur de la bordure
fillOpacity = 0.7,  # Opacité du remplissage
label = ~paste("<strong>Région:</strong>", ADM1_FR, "<br>",
"<strong>CDI:</strong>", round(CDI, 2)),  # Infobulle
highlightOptions = highlightOptions(
weight = 3,
color = "blue",
fillOpacity = 0.9,
bringToFront = TRUE
)
) %>%
addLegend(
pal = palette_CDI,
values = ~CDI,
position = "bottomright",
title = "CDI",
labFormat = labelFormat(suffix = ""),
opacity = 1
)
# Charger les shapefiles
shp_region <- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles/sen_admbnda_adm1_anat_20240520.shp", quiet = TRUE)
shp_departement <- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles/sen_admbnda_adm2_anat_20240520.shp", quiet = TRUE)
shp_commune <- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles/sen_admbnda_adm3_anat_20240520.shp", quiet = TRUE)
# Calculer les valeurs de population et de production pour chaque niveau
pop_count_region <- extract(pop_resampled_binary, shp_region, fun = sum, na.rm = TRUE)
prod_count_region <- extract(mult_raster, shp_region, fun = sum, na.rm = TRUE)
CDI_region <- prod_count_region / pop_count_region
pop_count_departement <- extract(pop_resampled_binary, shp_departement, fun = sum, na.rm = TRUE)
prod_count_departement <- extract(mult_raster, shp_departement, fun = sum, na.rm = TRUE)
CDI_departement <- prod_count_departement / pop_count_departement
pop_count_commune <- extract(pop_resampled_binary, shp_commune, fun = sum, na.rm = TRUE)
prod_count_commune <- extract(mult_raster, shp_commune, fun = sum, na.rm = TRUE)
CDI_commune <- prod_count_commune / pop_count_commune
# Ajouter les valeurs CDI aux shapefiles
shp_region$CDI <- CDI_region
shp_departement$CDI <- CDI_departement
shp_commune$CDI <- CDI_commune
# a. Carte des Régions
palette_CDI_region <- colorNumeric(palette = "viridis", domain = shp_region$CDI, na.color = "gray")
leaflet(data = shp_region) %>%
addTiles() %>%
addPolygons(
fillColor = ~palette_CDI_region(CDI),
weight = 1,
color = "white",
fillOpacity = 0.7,
label = ~paste("<strong>Région:</strong>", ADM1_FR, "<br>",
"<strong>CDI:</strong>", round(CDI, 2)),
highlightOptions = highlightOptions(
weight = 3,
color = "blue",
fillOpacity = 0.9,
bringToFront = TRUE
)
) %>%
addLegend(
pal = palette_CDI_region,
values = ~CDI,
position = "bottomright",
title = "CDI Régions",
labFormat = labelFormat(suffix = ""),
opacity = 1
)
# c. Carte des Communes
palette_CDI_commune <- colorNumeric(palette = "viridis", domain = shp_commune$CDI, na.color = "gray")
leaflet(data = shp_commune) %>%
addTiles() %>%
addPolygons(
fillColor = ~palette_CDI_commune(CDI),
weight = 1,
color = "white",
fillOpacity = 0.7,
label = ~paste("Commune:", ADM3_FR, "<br>",
"CDI:", round(CDI, 2)),
highlightOptions = highlightOptions(
weight = 3,
color = "blue",
fillOpacity = 0.9,
bringToFront = TRUE
)
) %>%
addLegend(
pal = palette_CDI_commune,
values = ~CDI,
position = "bottomright",
title = "CDI Communes",
labFormat = labelFormat(suffix = ""),
opacity = 1
)
leaflet(data = shp_commune) %>%
addTiles() %>%
addPolygons(
fillColor = ~palette_CDI_commune(CDI),
weight = 1,
color = "white",
fillOpacity = 0.7,
label = ~paste("Commune:", ADM3_FR, " ",
"CDI:", round(CDI, 2)),
highlightOptions = highlightOptions(
weight = 3,
color = "blue",
fillOpacity = 0.9,
bringToFront = TRUE
)
) %>%
addLegend(
pal = palette_CDI_commune,
values = ~CDI,
position = "bottomright",
title = "CDI Communes",
labFormat = labelFormat(suffix = ""),
opacity = 1
)
### Vérifier un résumé des valeurs du raster résultant
writeRaster(pop_resampled_binary, "C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Rasters/CDI/pop_resampled_binary.tif", format = "GTiff", overwrite = TRUE)
pop <- raster("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/BFA/BFA_population_v1_1_gridded.tif")
data <- read.csv("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Points_data.csv")
View(data)
View(data)
# On selectionne donc le pays
BFA = "Burkina Faso"
# Créer un sous-ensemble de données ne contenant que les événements relatifs au Mali
AOI_event <- data_spatial %>%
filter(country == BFA)
plot(AOI_event)
# Visualisation des événements au Mali
ggplot(AOI_event) +
aes(fill = event_type, colour = event_type) + # Associer les couleurs aux types d'événements
geom_sf(size = 1.2) + # Représentation des géométries spatiales
scale_fill_hue(direction = 1) + # Échelle de couleur pour les types d'événements
theme_minimal()
# Fonction pour créer un raster basé sur les données géolocalisées
Create_raster <- function(datafile, filename = "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation.tif") {
# Reprojection des données spatiales pour un système de coordonnées en mètres
# EPSG 32629 : UTM Zone 29N, adapté au Mali
AOI_prj <- st_transform(datafile, crs = 32629)
# Définir l'étendue géographique (extent) à partir des limites de l'objet spatial reprojeté
ext <- raster::extent(sf::st_bbox(AOI_prj))  # Conversion des limites en format `extent`
# Spécification de la résolution en mètres (5 km ici)
res <- 5000
# Définir un système de coordonnées pour le raster
rast_crs <- CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs")
raster_template <- raster::raster(ext = ext, resolution = res, crs = rast_crs)
# Rasteriser les données : calculer la somme des événements dans chaque cellule de la grille
Raster <- raster::rasterize(AOI_prj, raster_template, field = 1, fun = sum, na.rm = TRUE)
# Sauvegarder le raster en format GeoTIFF
raster::writeRaster(Raster, filename = filename, format = "GTiff", overwrite = TRUE)
return(Raster) # Pour retourner l'objet raster
}
# Application de la fonction sur les données des événements
AOI_Raster <- Create_raster(
AOI_event,
"C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif"
)
plot(AOI_Raster)
for( i in unique(data$year)){
assign(paste0("data_", i), data[data$year == i,])
assign(paste0("AOI_Raster_", i), Create_raster(AOI_event,  paste0("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_", i, ".tif")))# Création du raster pour chaque année et sauvegarde en fichier GeoTIFF
}
AOI_Raster_binaire <- AOI_Raster_2020
values(AOI_Raster_binaire) <- ifelse(values(AOI_Raster_2020) >= 5, 1, 0) # Les valeurs 1 sont prises si le nombre d'evenements est supérieur à 5
# Créer et binariser directement en excluant les NA
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) >= 5] <- 1
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) < 5] <- 0
pop <- raster("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/BFA/BFA_population_v1_1_gridded.tif")
### Agréger le raster à 5 km en utilisant la somme
fact <- round(5000/100)
pop_5km <- aggregate(pop, fact = fact, fun = sum, na.rm = TRUE)
crs(pop_5km) # En degres (CRS=WGS84)
crs(AOI_Raster_binaire) # En metre (UTM zone 29N)
pop_5km_utm <- projectRaster(pop_5km, crs = crs(AOI_Raster_binaire), method = "ngb")
crs(pop_5km_utm) # C'est maintenant en en metre (UTM zone 29N)
res(pop_5km_utm)
res(AOI_Raster_binaire)
pop_resampled <- resample(pop_5km_utm, AOI_Raster_binaire, method = "ngb")
pop_resampled_binary <- calc(pop_resampled, fun = function(x) {
ifelse(x < 50, 0, 1)
})
print(unique(values(pop_resampled_binary)))
dim_AOI <- dim(AOI_Raster_binaire)
dim_pop <- dim(pop_resampled_binary)
print(paste("Dimensions du raster AOI_Raster_binaire : ", paste(dim_AOI, collapse = " x ")))
print(paste("Dimensions du raster pop_5km_binary : ", paste(dim_pop, collapse = " x ")))
print(unique(values(pop_resampled_binary)))
print(unique(values(AOI_Raster_binaire)))
mult_raster <- AOI_Raster_binaire * pop_resampled_binary
### Vérifier un résumé des valeurs du raster résultant
writeRaster(pop_resampled_binary, "C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/CDI/pop_resampled_binary.tif", format = "GTiff", overwrite = TRUE)
writeRaster(mult_raster, "C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/CDI/mult_raster.tif", format = "GTiff", overwrite = TRUE)
plot(pop_resampled_binary)
plot(mult_raster)
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
NDBI <- raster("C:/Users/HP/Downloads/NDBI_Senegal.tif")
View(NDBI)
plot(NDBI)
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
NDVI <- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/Indices_spectraux/NDVI_Burkina.tif")
plot(NDVI)
runApp('Scripts R KD/app_KD.R')
NDVI <- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Rasters/Indices_spectraux/NDVI_Senegal.tif")
plot(NDVI)
NNDVI<- raster("C:/Users/HP/Downloads/NDVI_Burkina (1).tif")
plot(NNDVI)
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
pop <- raster("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/SEN/SEN_population_v0_1_gridded.tif")
pop <- raster("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/SEN/SEN_population_v1_0_gridded.tif")
data <- read.csv("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Points_data.csv")
shp <- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles/sen_admbnda_adm0_anat_20240520.shp")
data_spatial <- sf::st_as_sf(data, coords = c("longitude", "latitude"), crs = st_crs(shp))
# On selectionne donc le pays
BFA = "Senegal"
# Créer un sous-ensemble de données ne contenant que les événements relatifs au Mali
AOI_event <- data_spatial %>%
filter(country == BFA)
plot(AOI_event)
# Visualisation des événements au Mali
ggplot(AOI_event) +
aes(fill = event_type, colour = event_type) + # Associer les couleurs aux types d'événements
geom_sf(size = 1.2) + # Représentation des géométries spatiales
scale_fill_hue(direction = 1) + # Échelle de couleur pour les types d'événements
theme_minimal()
# Fonction pour créer un raster basé sur les données géolocalisées
Create_raster <- function(datafile, filename = "C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation.tif") {
# Reprojection des données spatiales pour un système de coordonnées en mètres
# EPSG 32629 : UTM Zone 29N, adapté au Mali
AOI_prj <- st_transform(datafile, crs = 32629)
# Définir l'étendue géographique (extent) à partir des limites de l'objet spatial reprojeté
ext <- raster::extent(sf::st_bbox(AOI_prj))  # Conversion des limites en format `extent`
# Spécification de la résolution en mètres (5 km ici)
res <- 5000
# Définir un système de coordonnées pour le raster
rast_crs <- CRS("+proj=utm +zone=29 +datum=WGS84 +units=m +no_defs")
raster_template <- raster::raster(ext = ext, resolution = res, crs = rast_crs)
# Rasteriser les données : calculer la somme des événements dans chaque cellule de la grille
Raster <- raster::rasterize(AOI_prj, raster_template, field = 1, fun = sum, na.rm = TRUE)
# Sauvegarder le raster en format GeoTIFF
raster::writeRaster(Raster, filename = filename, format = "GTiff", overwrite = TRUE)
return(Raster) # Pour retourner l'objet raster
}
# Application de la fonction sur les données des événements
AOI_Raster <- Create_raster(
AOI_event,
"C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_general.tif"
)
plot(AOI_Raster)
for( i in unique(data$year)){
assign(paste0("data_", i), data[data$year == i,])
assign(paste0("AOI_Raster_", i), Create_raster(AOI_event,  paste0("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/ISEP3/Stat_spatiales/TP11/Rasterisation_", i, ".tif")))# Création du raster pour chaque année et sauvegarde en fichier GeoTIFF
}
AOI_Raster_binaire <- AOI_Raster_2020
values(AOI_Raster_binaire) <- ifelse(values(AOI_Raster_2020) >= 5, 1, 0) # Les valeurs 1 sont prises si le nombre d'evenements est supérieur à 5
# Créer et binariser directement en excluant les NA
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) >= 5] <- 1
AOI_Raster_binaire[!is.na(values(AOI_Raster)) & values(AOI_Raster) < 5] <- 0
pop <- raster("C:/Users/HP/OneDrive/1231116193333-Desktop/Desktop/Stat_explo_spatiale/Statistique-Exploratoire-Spatiale/TP4/data/WorldPop/SEN/SEN_population_v1_0_gridded.tif")
### Agréger le raster à 5 km en utilisant la somme
fact <- round(5000/100)
pop_5km <- aggregate(pop, fact = fact, fun = sum, na.rm = TRUE)
crs(pop_5km) # En degres (CRS=WGS84)
crs(AOI_Raster_binaire) # En metre (UTM zone 29N)
pop_5km_utm <- projectRaster(pop_5km, crs = crs(AOI_Raster_binaire), method = "ngb")
crs(pop_5km_utm) # C'est maintenant en en metre (UTM zone 29N)
res(pop_5km_utm)
res(AOI_Raster_binaire)
pop_resampled <- resample(pop_5km_utm, AOI_Raster_binaire, method = "ngb")
pop_resampled_binary <- calc(pop_resampled, fun = function(x) {
ifelse(x < 50, 0, 1)
})
print(unique(values(pop_resampled_binary)))
dim_AOI <- dim(AOI_Raster_binaire)
dim_pop <- dim(pop_resampled_binary)
print(paste("Dimensions du raster AOI_Raster_binaire : ", paste(dim_AOI, collapse = " x ")))
print(paste("Dimensions du raster pop_5km_binary : ", paste(dim_pop, collapse = " x ")))
print(unique(values(pop_resampled_binary)))
print(unique(values(AOI_Raster_binaire)))
mult_raster <- AOI_Raster_binaire * pop_resampled_binary
### Vérifier un résumé des valeurs du raster résultant
writeRaster(pop_resampled_binary, "C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Rasters/CDI/pop_resampled_binary.tif", format = "GTiff", overwrite = TRUE)
writeRaster(mult_raster, "C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Rasters/CDI/mult_raster.tif", format = "GTiff", overwrite = TRUE)
plot(mult_raster)
runApp('Scripts R KD/app_KD.R')
a<- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/CDI/mult_raster.tif")
plot(a)
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
a<- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/CDI/pop_resampled_binary.tif")
plot(a)
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
a<- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Rasters/CDI/pop_resampled_binary.tif")
plot(a)
a<- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Rasters/CDI/mult_raster.tif")
plot(a)
runApp('Scripts R KD/app_KD.R')
a<- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/CDI/mult_raster.tif")
plot(a)
a<- raster("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Burkina/Rasters/CDI/pop_resampled_binary.tif")
plot(a)
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
=======
title = "Tableau",
br(),
h4("Tableau des Départements"),
downloadButton(ns("download_dep_table"), "Télécharger (CSV)"),
tableOutput(ns("dep_table")),
h4("Tableau des Communes"),
downloadButton(ns("download_com_table"), "Télécharger (CSV)"),
tableOutput(ns("com_table")),
hr(),
textOutput(ns("table_comment"))
),
# --- Onglet Graphique ---
tabPanel(
title = "Graphique",
br(),
plotOutput(ns("dep_plot"), height = "300px"),
downloadButton(ns("download_dep_plot"), "Télécharger Graphique Départements (PNG)"),
plotOutput(ns("com_plot"), height = "300px"),
downloadButton(ns("download_com_plot"), "Télécharger Graphique Communes (PNG)")
)
)
)
)
)
)
)
}
mod_state_filter_page_server <- function(id, landing_inputs, indicator_chosen_) {
moduleServer(id, function(input, output, session) {
data_reac <- reactive({ landing_inputs() })
# 1) Mettre à jour la liste de régions dès que data_global$regions est modifié (multi-pays)
observeEvent(data_global$regions, {
req(data_global$regions)
region_choices <- sort(unique(data_global$regions$ADM1_FR))
updateSelectInput(
session, "region",
choices = c("", region_choices),
selected = ""
)
})
# 2) Titres
output$selected_indicator_title <- renderText({
req(data_reac()$indicator_chosen)
paste("Indicateur sélectionné :", data_reac()$indicator_chosen)
})
output$selected_region_title <- renderText({
req(input$region)
paste("Région sélectionnée :", input$region)
})
# 3) Fonction pour la fourchette
getRange <- function(signif_str) {
if (signif_str == "Moins de 0.3") return(c(-Inf, 0.3))
if (signif_str == "0.3 à 0.6")   return(c(0.3, 0.6))
if (signif_str == "Plus de 0.6") return(c(0.6, Inf))
c(-Inf, Inf)  # Par défaut
}
# 4) Colonne selon l’indicateur
chosen_col <- reactive({
switch(
data_reac()$indicator_chosen,
"Taux moyen de Paludisme"          = "mean_index",
"Taux de malaria chez les enfants" = "taux_malaria_enfants",
"NDVI"                             = "mean_ndvi",
NULL
)
})
validate_chosen_col <- reactive({
if (is.null(chosen_col())) {
showNotification("Aucun indicateur valide n'est sélectionné.", type = "error")
stop("Colonne choisie NULL.")
}
chosen_col()
})
# 5) Filtrage
deps_filtered <- reactive({
req(input$region, validate_chosen_col())
minmax <- getRange(input$signif)
data_global$departments %>%
filter(
ADM1_FR == input$region,
.data[[chosen_col()]] >= minmax[1],
.data[[chosen_col()]] <= minmax[2]
)
})
coms_filtered <- reactive({
req(input$region, validate_chosen_col())
minmax <- getRange(input$signif)
data_global$communes %>%
filter(
ADM1_FR == input$region,
.data[[chosen_col()]] >= minmax[1],
.data[[chosen_col()]] <= minmax[2]
)
})
# 6) Tableau Résumé
summary_table_reactive <- reactive({
req(input$region, validate_chosen_col())
dep_vals <- deps_filtered()[[chosen_col()]]
com_vals <- coms_filtered()[[chosen_col()]]
reg_val <- data_global$regions %>%
filter(ADM1_FR == input$region) %>%
pull(chosen_col())
data.frame(
row.names = c("Moyenne", "Maximum", "Minimum"),
"Région"      = c(
round(mean(reg_val, na.rm = TRUE), 3),
round(max(reg_val, na.rm = TRUE), 3),
round(min(reg_val, na.rm = TRUE), 3)
),
"Département" = c(
round(mean(dep_vals, na.rm = TRUE), 3),
round(max(dep_vals, na.rm = TRUE), 3),
round(min(dep_vals, na.rm = TRUE), 3)
),
"Commune"     = c(
round(mean(com_vals, na.rm = TRUE), 3),
round(max(com_vals, na.rm = TRUE), 3),
round(min(com_vals, na.rm = TRUE), 3)
)
)
})
output$resume_table <- renderTable({
summary_table_reactive()
}, rownames = TRUE)
output$resume_comment <- renderText({
"Interprétation : ce tableau compare la valeur régionale et les valeurs des départements/communes filtrés."
})
# *** Téléchargement du tableau Résumé ***
output$download_resume_table <- downloadHandler(
filename = function(){
paste0("resume_table_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(summary_table_reactive(), file, row.names = TRUE)
}
)
# 7) Tableaux départements / communes
output$dep_table <- renderTable({
req(input$region, validate_chosen_col())
df <- deps_filtered()
data.frame(
Département = df$ADM2_FR,
Taux = round(df[[chosen_col()]], 3)
)
})
output$com_table <- renderTable({
req(input$region, validate_chosen_col())
df <- coms_filtered()
data.frame(
Commune = df$ADM3_FR,
Taux = round(df[[chosen_col()]], 3)
)
})
output$table_comment <- renderText({
"Tableaux listant les départements et communes respectant le filtre choisi."
})
# Téléchargements CSV pour Départements / Communes
output$download_dep_table <- downloadHandler(
filename = function(){
paste0("departements_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(deps_filtered(), file, row.names = FALSE)
}
)
output$download_com_table <- downloadHandler(
filename = function(){
paste0("communes_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(coms_filtered(), file, row.names = FALSE)
}
)
# 8) Graphiques Départements / Communes
output$dep_plot <- renderPlot({
req(input$region, validate_chosen_col())
>>>>>>> 9f42805222f6f5bd256da476880d6c3d8749de88
df <- deps_filtered()
ggplot(df, aes(x = ADM2_FR, y = .data[[chosen_col()]], group = 1)) +
geom_line(color = "blue") +
geom_point(color = "blue", size = 2) +
theme_minimal() +
labs(title = "Taux par Département", x = "Département", y = "Valeur") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
output$com_plot <- renderPlot({
req(input$region, validate_chosen_col())
df <- coms_filtered()
ggplot(df, aes(x = ADM3_FR, y = .data[[chosen_col()]], group = 1)) +
geom_line(color = "red") +
geom_point(color = "red", size = 2) +
theme_minimal() +
labs(title = "Taux par Commune", x = "Commune", y = "Valeur") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
# Téléchargements PNG pour Départements / Communes
output$download_dep_plot <- downloadHandler(
filename = function() {
paste0("graphique_departements_", input$region, "_", Sys.Date(), ".png")
},
content = function(file) {
df <- deps_filtered()
p <- ggplot(df, aes(x = ADM2_FR, y = .data[[chosen_col()]])) +
geom_line(color = "blue") +
geom_point(color = "blue") +
theme_minimal() +
labs(title = "Graphique par Département", x = "Département", y = "Valeur")
ggsave(file, plot = p, device = "png", width = 10, height = 6)
}
)
output$download_com_plot <- downloadHandler(
filename = function() {
paste0("graphique_communes_", input$region, "_", Sys.Date(), ".png")
},
content = function(file) {
df <- coms_filtered()
p <- ggplot(df, aes(x = ADM3_FR, y = .data[[chosen_col()]])) +
geom_line(color = "red") +
geom_point(color = "red") +
theme_minimal() +
labs(title = "Graphique par Commune", x = "Commune", y = "Valeur")
ggsave(file, plot = p, device = "png", width = 10, height = 6)
}
)
})
}
runApp('Scripts R Salam/app_KD.R')
>>>>>>> be81c32eecd974477f59bbd98a8bb95e18dd8f3b
# ─────────────────────────────────────────────────────────────────────────────
# mod_state_filter_page_KD.R
# Module 4 : Sélection d’une Région, puis onglets Résumé, Tableau, Graphique
# + Téléchargements
# ─────────────────────────────────────────────────────────────────────────────
<<<<<<< HEAD
pop_df <- as.data.frame(rasterToPoints(pop), stringsAsFactors = FALSE)
runApp('C:/Users/ALIOUNE KANE/Downloads/Projet_Final_Stats_Spatiales/Scripts R')
runApp('C:/Users/ALIOUNE KANE/Downloads/Projet_Final_Stats_Spatiales/Scripts R')
shiny::runApp('Scripts R')
library(shiny); runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
# ─────────────────────────────────────────────────────────────────────────────
# mod_about_page.R
# Page "About"
# ─────────────────────────────────────────────────────────────────────────────
mod_about_page_ui <- function(id) {
ns <- NS(id)
tagList(
# Vous pouvez aussi utiliser fluidPage ou fluidRow si vous préférez
fluidRow(
column(
width = 12,
tags$h2("À propos"),
tags$p("Ici, vous pouvez décrire l'objectif général de l'application, ",
"la méthodologie d'ensemble, vos sources de données, etc."),
tags$hr(),
tags$p("Lorem ipsum dolor sit amet, consectetur adipiscing elit. ",
"Sed nec risus quis libero ornare semper. Praesent vehicula ",
"justo non faucibus sollicitudin. Pellentesque vehicula augue ",
"a sollicitudin sodales. Proin blandit sit amet erat non ",
"feugiat... (texte d'exemple à remplacer).")
=======
mod_state_filter_page_ui <- function(id){
ns <- NS(id)
fluidPage(
# Le module n’apparaît que si le pays ET l’indicateur sont sélectionnés
conditionalPanel(
condition = sprintf("input['landing_page-country'] !== '' && input['landing_page-indicator_chosen'] !== ''"),
fluidRow(
column(
width = 3,
# Liste dynamique des régions (on mettra à jour dans le server)
selectInput(ns("region"), "Sélectionnez une Région :",
choices = c("")),
selectInput(ns("signif"), "Filtrer par Significativité (ou seuil) :",
choices = c("Afficher tout", "Moins de 0.3", "0.3 à 0.6", "Plus de 0.6")),
helpText("Les données affichées peuvent être filtrées selon la fourchette de valeurs.")
),
column(
width = 9,
# Afficher la suite uniquement si on a choisi une région
conditionalPanel(
condition = sprintf("input['%s'] != ''", ns("region")),
div(
class = "dark-box",
div(
class = "red-title-box",
textOutput(ns("selected_indicator_title"))
),
div(
class = "red-title-box",
textOutput(ns("selected_region_title"))
=======
>>>>>>> eb627a0fbdfa9518fc6f8f80df611e8bbd227940
),
p("Nous présentons ci-dessous les statistiques résumées par région ",
"pour l'indicateur sélectionné.")
),
tabsetPanel(
# --- Onglet Résumé ---
tabPanel(
title = "Résumé",
br(),
# Bouton de téléchargement pour le tableau résumé
downloadButton(ns("download_resume_table"), "Télécharger le résumé (CSV)"),
tableOutput(ns("resume_table")),
hr(),
textOutput(ns("resume_comment"))
),
# --- Onglet Tableau ---
tabPanel(
title = "Tableau",
br(),
h4("Tableau des Départements"),
downloadButton(ns("download_dep_table"), "Télécharger (CSV)"),
tableOutput(ns("dep_table")),
h4("Tableau des Communes"),
downloadButton(ns("download_com_table"), "Télécharger (CSV)"),
tableOutput(ns("com_table")),
hr(),
textOutput(ns("table_comment"))
),
# --- Onglet Graphique ---
tabPanel(
title = "Graphique",
br(),
plotOutput(ns("dep_plot"), height = "300px"),
downloadButton(ns("download_dep_plot"), "Télécharger Graphique Départements (PNG)"),
plotOutput(ns("com_plot"), height = "300px"),
downloadButton(ns("download_com_plot"), "Télécharger Graphique Communes (PNG)")
)
)
)
)
>>>>>>> be81c32eecd974477f59bbd98a8bb95e18dd8f3b
)
)
)
}
<<<<<<< HEAD
mod_about_page_server <- function(id) {
moduleServer(id, function(input, output, session) {
# A priori, rien de particulier dans le serveur pour une page statique
})
}
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
# ─────────────────────────────────────────────────────────────────────────────
# global_KD.R
# Chargement des librairies, définition des indicateurs,
# et gestion multi-pays (Sénégal/Burkina) avec calculs par niveau admin.
# ─────────────────────────────────────────────────────────────────────────────
# 1) Chargement des bibliothèques
library(shiny)
library(shinyjs)
library(leaflet)
library(dplyr)
library(ggplot2)
library(sf)
library(raster)
library(exactextractr)
library(viridis)
# 2) Définition des indicateurs par pays
fake_indicators <- list(
"Senegal" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants", "NDVI"),
"Burkina" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants", "NDVI")
)
# 3) Paramétrage des chemins de shapefiles/rasters par pays
#    Adaptez à votre propre organisation des dossiers !
chemin_base <- "C:/Users/ALIOUNE KANE/Downloads/Projet_Final_Stats_Spatiales/data"
shapefile_noms <- list(
"Senegal" = list(
adm1 = "sen_admbnda_adm1_anat_20240520.shp",
adm2 = "sen_admbnda_adm2_anat_20240520.shp",
adm3 = "sen_admbnda_adm3_anat_20240520.shp"
),
"Burkina" = list(
adm1 = "bfa_admbnda_adm1_igb_20200323.shp",
adm2 = "bfa_admbnda_adm2_igb_20200323.shp",
adm3 = "bfa_admbnda_adm3_igb_20200323.shp"
)
)
# 4) Fonction pour charger les shapefiles/rasters d’un pays
charger_donnees_pays <- function(pays) {
# Shapefiles
shapefile_path <- file.path(chemin_base, pays, "Shapefiles")
noms <- shapefile_noms[[pays]]
regions     <- st_read(file.path(shapefile_path, noms$adm1), quiet = TRUE)
departments <- st_read(file.path(shapefile_path, noms$adm2), quiet = TRUE)
communes    <- st_read(file.path(shapefile_path, noms$adm3), quiet = TRUE)
# Rasters
raster_path <- file.path(chemin_base, pays, "Rasters")
fichiers_raster <- list.files(raster_path, pattern = "\\.tiff$", full.names = TRUE)
# On stack tous les .tiff
if (length(fichiers_raster) > 0) {
rasters <- stack(fichiers_raster)
mean_raster <- calc(rasters, fun = mean, na.rm = TRUE)
} else {
mean_raster <- NULL
}
# EXEMPLE : rasters additionnels
# À adapter selon vos vrais fichiers
raster_nombre_malaria_enfants <- raster(file.path(raster_path, "malaria_enfants/raster_nombre_malaria_enfants.tif"))
raster_pop_enfants <- raster(file.path(raster_path, "malaria_enfants/raster_pop_enfants.tif"))
ndvi_raster <- raster(file.path(raster_path, paste0("Indices_spectraux/NDVI_", pays, ".tif")))
list(
regions = regions,
departments = departments,
communes = communes,
mean_raster = mean_raster,
raster_nombre_malaria_enfants = raster_nombre_malaria_enfants,
raster_pop_enfants = raster_pop_enfants,
ndvi_raster = ndvi_raster
)
}
# 5) Calculs de base pour enrichir les shapefiles
calculer_indicateurs <- function(donnees) {
# Récupération
regions     <- donnees$regions
departments <- donnees$departments
communes    <- donnees$communes
mean_raster      <- donnees$mean_raster
raster_malaria   <- donnees$raster_nombre_malaria_enfants
raster_pop       <- donnees$raster_pop_enfants
ndvi_raster      <- donnees$ndvi_raster
# Si le raster est NULL (en cas d’absence de fichiers), on gère prudemment
if (!is.null(mean_raster)) {
# Taux moyen de paludisme (exemple)
regions$mean_index     <- exact_extract(mean_raster, regions, 'mean')
departments$mean_index <- exact_extract(mean_raster, departments, 'mean')
communes$mean_index    <- exact_extract(mean_raster, communes, 'mean')
}
if (!is.null(ndvi_raster)) {
regions$mean_ndvi     <- exact_extract(ndvi_raster, regions, 'mean')
departments$mean_ndvi <- exact_extract(ndvi_raster, departments, 'mean')
communes$mean_ndvi    <- exact_extract(ndvi_raster, communes, 'mean')
}
if (!is.null(raster_malaria) && !is.null(raster_pop)) {
# Taux malaria enfants = sum(malaria_enf) / sum(pop_enf)
reg_mal <- exact_extract(raster_malaria, regions, 'sum')
reg_pop <- exact_extract(raster_pop,     regions, 'sum')
regions$taux_malaria_enfants <- ifelse(reg_pop > 0, reg_mal / reg_pop, NA)
dep_mal <- exact_extract(raster_malaria, departments, 'sum')
dep_pop <- exact_extract(raster_pop,     departments, 'sum')
departments$taux_malaria_enfants <- ifelse(dep_pop > 0, dep_mal / dep_pop, NA)
com_mal <- exact_extract(raster_malaria, communes, 'sum')
com_pop <- exact_extract(raster_pop,     communes, 'sum')
communes$taux_malaria_enfants <- ifelse(com_pop > 0, com_mal / com_pop, NA)
}
list(
regions = regions,
departments = departments,
communes = communes
)
}
# 6) Stockage "global" réactif (pour le pays en cours)
data_global <- reactiveValues(
regions = NULL,
departments = NULL,
communes = NULL,
mean_raster = NULL,
raster_nombre_malaria_enfants = NULL,
raster_pop_enfants = NULL,
ndvi_raster = NULL
)
# 7) Fonction qui met à jour data_global selon le pays
update_data_global <- function(pays) {
# Charger
donnees_brutes <- charger_donnees_pays(pays)
# Calculer les indicateurs
res <- calculer_indicateurs(donnees_brutes)
data_global$regions     <- res$regions
data_global$departments <- res$departments
data_global$communes    <- res$communes
data_global$mean_raster                <- donnees_brutes$mean_raster
data_global$raster_nombre_malaria_enfants <- donnees_brutes$raster_nombre_malaria_enfants
data_global$raster_pop_enfants         <- donnees_brutes$raster_pop_enfants
data_global$ndvi_raster                <- donnees_brutes$ndvi_raster
message("Données mises à jour pour le pays : ", pays)
}
# Fin de global_KD.R
# ─────────────────────────────────────────────────────────────────────────────
=======
mod_state_filter_page_server <- function(id, landing_inputs, indicator_chosen_) {
moduleServer(id, function(input, output, session) {
data_reac <- reactive({ landing_inputs() })
# 1) Mettre à jour la liste de régions dès que data_global$regions est modifié (multi-pays)
observeEvent(data_global$regions, {
req(data_global$regions)
region_choices <- sort(unique(data_global$regions$ADM1_FR))
updateSelectInput(
session, "region",
choices = c("", region_choices),
selected = ""
)
})
# 2) Titres
output$selected_indicator_title <- renderText({
req(data_reac()$indicator_chosen)
paste("Indicateur sélectionné :", data_reac()$indicator_chosen)
})
output$selected_region_title <- renderText({
req(input$region)
paste("Région sélectionnée :", input$region)
})
# 3) Fonction pour la fourchette
getRange <- function(signif_str) {
if (signif_str == "Moins de 0.3") return(c(-Inf, 0.3))
if (signif_str == "0.3 à 0.6")   return(c(0.3, 0.6))
if (signif_str == "Plus de 0.6") return(c(0.6, Inf))
c(-Inf, Inf)  # Par défaut
}
# 4) Colonne selon l’indicateur
chosen_col <- reactive({
switch(
data_reac()$indicator_chosen,
"Taux moyen de Paludisme"          = "mean_index",
"Taux de malaria chez les enfants" = "taux_malaria_enfants",
"NDVI"                             = "mean_ndvi",
NULL
)
})
validate_chosen_col <- reactive({
if (is.null(chosen_col())) {
showNotification("Aucun indicateur valide n'est sélectionné.", type = "error")
stop("Colonne choisie NULL.")
}
chosen_col()
})
# 5) Filtrage
deps_filtered <- reactive({
req(input$region, validate_chosen_col())
minmax <- getRange(input$signif)
data_global$departments %>%
filter(
ADM1_FR == input$region,
.data[[chosen_col()]] >= minmax[1],
.data[[chosen_col()]] <= minmax[2]
)
})
coms_filtered <- reactive({
req(input$region, validate_chosen_col())
minmax <- getRange(input$signif)
data_global$communes %>%
filter(
ADM1_FR == input$region,
.data[[chosen_col()]] >= minmax[1],
.data[[chosen_col()]] <= minmax[2]
)
})
# 6) Tableau Résumé
summary_table_reactive <- reactive({
req(input$region, validate_chosen_col())
dep_vals <- deps_filtered()[[chosen_col()]]
com_vals <- coms_filtered()[[chosen_col()]]
reg_val <- data_global$regions %>%
filter(ADM1_FR == input$region) %>%
pull(chosen_col())
data.frame(
row.names = c("Moyenne", "Maximum", "Minimum"),
"Région"      = c(
round(mean(reg_val, na.rm = TRUE), 3),
round(max(reg_val, na.rm = TRUE), 3),
round(min(reg_val, na.rm = TRUE), 3)
),
"Département" = c(
round(mean(dep_vals, na.rm = TRUE), 3),
round(max(dep_vals, na.rm = TRUE), 3),
round(min(dep_vals, na.rm = TRUE), 3)
),
"Commune"     = c(
round(mean(com_vals, na.rm = TRUE), 3),
round(max(com_vals, na.rm = TRUE), 3),
round(min(com_vals, na.rm = TRUE), 3)
)
)
})
output$resume_table <- renderTable({
summary_table_reactive()
}, rownames = TRUE)
output$resume_comment <- renderText({
"Interprétation : ce tableau compare la valeur régionale et les valeurs des départements/communes filtrés."
})
# *** Téléchargement du tableau Résumé ***
output$download_resume_table <- downloadHandler(
filename = function(){
paste0("resume_table_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(summary_table_reactive(), file, row.names = TRUE)
}
)
# 7) Tableaux départements / communes
output$dep_table <- renderTable({
req(input$region, validate_chosen_col())
df <- deps_filtered()
data.frame(
Département = df$ADM2_FR,
Taux = round(df[[chosen_col()]], 3)
)
})
output$com_table <- renderTable({
req(input$region, validate_chosen_col())
df <- coms_filtered()
data.frame(
Commune = df$ADM3_FR,
Taux = round(df[[chosen_col()]], 3)
)
})
output$table_comment <- renderText({
"Tableaux listant les départements et communes respectant le filtre choisi."
})
# Téléchargements CSV pour Départements / Communes
output$download_dep_table <- downloadHandler(
filename = function(){
paste0("departements_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(deps_filtered(), file, row.names = FALSE)
}
)
output$download_com_table <- downloadHandler(
filename = function(){
paste0("communes_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(coms_filtered(), file, row.names = FALSE)
}
)
# 8) Graphiques Départements / Communes
output$dep_plot <- renderPlot({
req(input$region, validate_chosen_col())
df <- deps_filtered()
ggplot(df, aes(x = ADM2_FR, y = .data[[chosen_col()]], group = 1)) +
geom_line(color = "blue") +
geom_point(color = "blue", size = 2) +
theme_minimal() +
labs(title = "Taux par Département", x = "Département", y = "Valeur") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
output$com_plot <- renderPlot({
req(input$region, validate_chosen_col())
df <- coms_filtered()
ggplot(df, aes(x = ADM3_FR, y = .data[[chosen_col()]], group = 1)) +
geom_line(color = "red") +
geom_point(color = "red", size = 2) +
theme_minimal() +
labs(title = "Taux par Commune", x = "Commune", y = "Valeur") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
# Téléchargements PNG pour Départements / Communes
output$download_dep_plot <- downloadHandler(
filename = function() {
paste0("graphique_departements_", input$region, "_", Sys.Date(), ".png")
},
content = function(file) {
df <- deps_filtered()
p <- ggplot(df, aes(x = ADM2_FR, y = .data[[chosen_col()]])) +
geom_line(color = "blue") +
geom_point(color = "blue") +
theme_minimal() +
labs(title = "Graphique par Département", x = "Département", y = "Valeur")
ggsave(file, plot = p, device = "png", width = 10, height = 6)
}
)
output$download_com_plot <- downloadHandler(
filename = function() {
paste0("graphique_communes_", input$region, "_", Sys.Date(), ".png")
},
content = function(file) {
df <- coms_filtered()
p <- ggplot(df, aes(x = ADM3_FR, y = .data[[chosen_col()]])) +
geom_line(color = "red") +
geom_point(color = "red") +
theme_minimal() +
labs(title = "Graphique par Commune", x = "Commune", y = "Valeur")
ggsave(file, plot = p, device = "png", width = 10, height = 6)
}
)
})
}
>>>>>>> be81c32eecd974477f59bbd98a8bb95e18dd8f3b
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
library(shiny); runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
runApp('Scripts R Salam/app_KD.R')
<<<<<<< HEAD
library(shiny); runApp('Scripts R Salam/app_KD.R')
=======
>>>>>>> 1b70d2eee25ff0e6dc68d10aa02b057159a2a2a5
<<<<<<< HEAD
>>>>>>> 9f42805222f6f5bd256da476880d6c3d8749de88
=======
library(shiny); runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R')
runApp('Scripts R KD/app_KD.R')
tag$a("Lien vers la vidéo de démonstration",href="Lien.html")
fluidPage(
tags$style(HTML(
"body { background-color: #f8f9fa; } \n
h2 { color: #007bff; } \n
.content-box { background-color: #ffffff; border-radius: 15px; padding: 20px; box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.1); } \n
.text-section { float: left; width: 50%; padding-right: 20px; } \n
.screenshot-section { float: right; width: 50%; text-align: center; } \n
.screenshot { margin: 10px auto; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); }"
)),
fluidRow(
column(
12,
div(class = "content-box",
tags$h2("Guide d'Utilisation"),
div(
class = "text-section",
tags$ol(
tags$li(tags$span(style = "font-weight: bold;", "Sélectionner un pays et un Indicateur:"),
" Choisissez un pays et un indicateur à afficher. La carte par défaut montre les valeurs au niveau Grid."),
tags$li(tags$span(style = "font-weight: bold;", "Navigation sur la Carte:"),
" Utilisez les boutons zoom avant (+) ou zoom arrière (-) pour ajuster la vue."),
tags$li(tags$span(style = "font-weight: bold;", "Définition de l'Indicateur:"),
" Une brève définition de l’indicateur calculé. Plus de détails sont disponibles dans la section Notes techniques, qui explique la 'Probabilité de Dépassement et la Confiance dans les Changements au Fil du Temps.'"),
tags$li(tags$span(style = "font-weight: bold;", "Détails sur la carte:"),
" Explorez les détails supplémentaires fournis sur la carte."),
tags$li(tags$span(style = "font-weight: bold;", "Filtrage par Changement:"),
" Ajustez les paramètres pour mettre en évidence l'indicateur à un niveau administratif."),
tags$li(tags$span(style = "font-weight: bold;", "Highlight une région:"),
" Mettez en valeur une région spécifique pour des analyses ciblées."),
tags$li(tags$span(style = "font-weight: bold;", "Ajustez le curseur:"),
" Affinez les résultats en fonction d’un seuil particulier."),
tags$li(tags$span(style = "font-weight: bold;", "Téléchargement des Données:"),
" Cliquez sur le bouton Télécharger situé en dessous de la carte ou au-dessus du tableau pour récupérer les données."),
tag$a("Lien vers la vidéo de démonstration",href="Lien.html")
)
),
div(
class = "screenshot-section",
tags$img(src = "LOGO1.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 1"),
tags$img(src = "LOGO2.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 2"),
tags$img(src = "LOGO3.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 3")
),
tags$div(style = "clear: both;") # Pour nettoyer le flottement
)
)
)
)
fluidPage(
tags$style(HTML(
"body { background-color: #f8f9fa; } \n
h2 { color: #007bff; } \n
.content-box { background-color: #ffffff; border-radius: 15px; padding: 20px; box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.1); } \n
.text-section { float: left; width: 50%; padding-right: 20px; } \n
.screenshot-section { float: right; width: 50%; text-align: center; } \n
.screenshot { margin: 10px auto; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); }"
)),
fluidRow(
column(
12,
div(class = "content-box",
tags$h2("Guide d'Utilisation"),
div(
class = "text-section",
tags$ol(
tags$li(tags$span(style = "font-weight: bold;", "Sélectionner un pays et un Indicateur:"),
" Choisissez un pays et un indicateur à afficher. La carte par défaut montre les valeurs au niveau Grid."),
tags$li(tags$span(style = "font-weight: bold;", "Navigation sur la Carte:"),
" Utilisez les boutons zoom avant (+) ou zoom arrière (-) pour ajuster la vue."),
tags$li(tags$span(style = "font-weight: bold;", "Définition de l'Indicateur:"),
" Une brève définition de l’indicateur calculé. Plus de détails sont disponibles dans la section Notes techniques, qui explique la 'Probabilité de Dépassement et la Confiance dans les Changements au Fil du Temps.'"),
tags$li(tags$span(style = "font-weight: bold;", "Détails sur la carte:"),
" Explorez les détails supplémentaires fournis sur la carte."),
tags$li(tags$span(style = "font-weight: bold;", "Filtrage par Changement:"),
" Ajustez les paramètres pour mettre en évidence l'indicateur à un niveau administratif."),
tags$li(tags$span(style = "font-weight: bold;", "Highlight une région:"),
" Mettez en valeur une région spécifique pour des analyses ciblées."),
tags$li(tags$span(style = "font-weight: bold;", "Ajustez le curseur:"),
" Affinez les résultats en fonction d’un seuil particulier."),
tags$li(tags$span(style = "font-weight: bold;", "Téléchargement des Données:"),
" Cliquez sur le bouton Télécharger situé en dessous de la carte ou au-dessus du tableau pour récupérer les données."),
tag$li(tag$a("Lien vers la vidéo de démonstration",href="Lien.html"))
)
),
div(
class = "screenshot-section",
tags$img(src = "LOGO1.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 1"),
tags$img(src = "LOGO2.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 2"),
tags$img(src = "LOGO3.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 3")
),
tags$div(style = "clear: both;") # Pour nettoyer le flottement
)
)
)
)
# ─────────────────────────────────────────────────────────────────────────────
# mod_guide_page.R
# Page "Guide"
# ─────────────────────────────────────────────────────────────────────────────
mod_guide_page_ui <- function(id) {
ns <- NS(id)
fluidPage(
tags$style(HTML(
"body { background-color: #f8f9fa; } \n
h2 { color: #007bff; } \n
.content-box { background-color: #ffffff; border-radius: 15px; padding: 20px; box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.1); } \n
.text-section { float: left; width: 50%; padding-right: 20px; } \n
.screenshot-section { float: right; width: 50%; text-align: center; } \n
.screenshot { margin: 10px auto; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); }"
)),
fluidRow(
column(
12,
div(class = "content-box",
tags$h2("Guide d'Utilisation"),
div(
class = "text-section",
tags$ol(
tags$li(tags$span(style = "font-weight: bold;", "Sélectionner un pays et un Indicateur:"),
" Choisissez un pays et un indicateur à afficher. La carte par défaut montre les valeurs au niveau Grid."),
tags$li(tags$span(style = "font-weight: bold;", "Navigation sur la Carte:"),
" Utilisez les boutons zoom avant (+) ou zoom arrière (-) pour ajuster la vue."),
tags$li(tags$span(style = "font-weight: bold;", "Définition de l'Indicateur:"),
" Une brève définition de l’indicateur calculé. Plus de détails sont disponibles dans la section Notes techniques, qui explique la 'Probabilité de Dépassement et la Confiance dans les Changements au Fil du Temps.'"),
tags$li(tags$span(style = "font-weight: bold;", "Détails sur la carte:"),
" Explorez les détails supplémentaires fournis sur la carte."),
tags$li(tags$span(style = "font-weight: bold;", "Filtrage par Changement:"),
" Ajustez les paramètres pour mettre en évidence l'indicateur à un niveau administratif."),
tags$li(tags$span(style = "font-weight: bold;", "Highlight une région:"),
" Mettez en valeur une région spécifique pour des analyses ciblées."),
tags$li(tags$span(style = "font-weight: bold;", "Ajustez le curseur:"),
" Affinez les résultats en fonction d’un seuil particulier."),
tags$li(tags$span(style = "font-weight: bold;", "Téléchargement des Données:"),
" Cliquez sur le bouton Télécharger situé en dessous de la carte ou au-dessus du tableau pour récupérer les données."),
tags$li(tags$a("Lien vers la vidéo de démonstration", href = "Lien.html", target = "_blank"))
)
),
div(
class = "screenshot-section",
tags$img(src = "LOGO1.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 1"),
tags$img(src = "LOGO2.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 2"),
tags$img(src = "LOGO3.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 3")
),
tags$div(style = "clear: both;") # Pour nettoyer le flottement
)
)
)
)
}
mod_guide_page_server <- function(id) {
moduleServer(id, function(input, output, session) { })
}
fluidPage(
tags$style(HTML(
"body { background-color: #f8f9fa; } \n
h2 { color: #007bff; } \n
.content-box { background-color: #ffffff; border-radius: 15px; padding: 20px; box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.1); } \n
.text-section { float: left; width: 50%; padding-right: 20px; } \n
.screenshot-section { float: right; width: 50%; text-align: center; } \n
.screenshot { margin: 10px auto; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); }"
)),
fluidRow(
column(
12,
div(class = "content-box",
tags$h2("Guide d'Utilisation"),
div(
class = "text-section",
tags$ol(
tags$li(tags$span(style = "font-weight: bold;", "Sélectionner un pays et un Indicateur:"),
" Choisissez un pays et un indicateur à afficher. La carte par défaut montre les valeurs au niveau national."),
tags$li(tags$span(style = "font-weight: bold;", "Navigation sur la Carte:"),
" Utilisez les boutons zoom avant (+) ou zoom arrière (-) pour ajuster la vue."),
tags$li(tags$span(style = "font-weight: bold;", "Définition de l'Indicateur:"),
" Une brève définition de l’indicateur calculé. Plus de détails sont disponibles dans la section Notes techniques, qui explique la 'Probabilité de Dépassement et la Confiance dans les Changements au Fil du Temps.'"),
tags$li(tags$span(style = "font-weight: bold;", "Détails sur la carte:"),
" Explorez les détails supplémentaires fournis sur la carte."),
tags$li(tags$span(style = "font-weight: bold;", "Filtrage par Changement:"),
" Ajustez les paramètres pour mettre en évidence l'indicateur à un niveau administratif."),
tags$li(tags$span(style = "font-weight: bold;", "Highlight une région:"),
" Mettez en valeur une région spécifique pour des analyses ciblées."),
tags$li(tags$span(style = "font-weight: bold;", "Ajustez le curseur:"),
" Affinez les résultats en fonction d’un seuil particulier."),
tags$li(tags$span(style = "font-weight: bold;", "Téléchargement des Données:"),
" Cliquez sur le bouton Télécharger situé en dessous de la carte ou au-dessus du tableau pour récupérer les données."),
tags$li(tags$a("Lien vers la vidéo de démonstration", href = "Lien.html", target = "_blank"))
)
),
div(
class = "screenshot-section",
tags$img(src = "LOGO1.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 1"),
tags$img(src = "LOGO2.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 2"),
tags$img(src = "LOGO3.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 3")
),
tags$div(style = "clear: both;") # Pour nettoyer le flottement
)
)
)
)
runApp('Scripts R KD/app_KD.R')
# ─────────────────────────────────────────────────────────────────────────────
# mod_guide_page.R
# Page "Guide"
# ─────────────────────────────────────────────────────────────────────────────
mod_guide_page_ui <- function(id) {
ns <- NS(id)
fluidPage(
tags$style(HTML(
"body { background-color: #f8f9fa; } \n
h2 { color: #007bff; } \n
.content-box { background-color: #ffffff; border-radius: 15px; padding: 20px; box-shadow: 1px 4px 6px rgba(0, 0, 0, 0.1); } \n
.text-section { float: left; width: 50%; padding-right: 20px; } \n
.screenshot-section { float: right; width: 50%; text-align: center; } \n
.screenshot { margin: 10px auto; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); }"
)),
fluidRow(
column(
12,
div(class = "content-box",
tags$h2("Guide d'Utilisation"),
div(
class = "text-section",
tags$ol(
tags$li(tags$span(style = "font-weight: bold;", "Sélectionner un pays et un Indicateur:"),
" Choisissez un pays et un indicateur à afficher. La carte par défaut montre les valeurs au niveau national."),
tags$li(tags$span(style = "font-weight: bold;", "Navigation sur la Carte:"),
" Utilisez les boutons zoom avant (+) ou zoom arrière (-) pour ajuster la vue."),
tags$li(tags$span(style = "font-weight: bold;", "Définition de l'Indicateur:"),
" Une brève définition de l’indicateur calculé. Plus de détails sont disponibles dans la section Notes techniques, qui explique la 'Probabilité de Dépassement et la Confiance dans les Changements au Fil du Temps.'"),
tags$li(tags$span(style = "font-weight: bold;", "Détails sur la carte:"),
" Explorez les détails supplémentaires fournis sur la carte."),
tags$li(tags$span(style = "font-weight: bold;", "Filtrage par Changement:"),
" Ajustez les paramètres pour mettre en évidence l'indicateur à un niveau administratif."),
tags$li(tags$span(style = "font-weight: bold;", "Highlight une région:"),
" Mettez en valeur une région spécifique pour des analyses ciblées."),
tags$li(tags$span(style = "font-weight: bold;", "Ajustez le curseur:"),
" Affinez les résultats en fonction d’un seuil particulier."),
tags$li(tags$span(style = "font-weight: bold;", "Téléchargement des Données:"),
" Cliquez sur le bouton Télécharger situé en dessous de la carte ou au-dessus du tableau pour récupérer les données."),
tags$a("Lien vers la vidéo de démonstration", href = "Lien.html", target = "_blank")
)
),
div(
class = "screenshot-section",
tags$img(src = "LOGO1.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 1"),
tags$img(src = "LOGO2.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 2"),
tags$img(src = "LOGO3.JPEG", class = "screenshot", width = "90%", alt = "Screenshot 3")
),
tags$div(style = "clear: both;") # Pour nettoyer le flottement
)
)
)
)
}
runApp('Scripts R KD/app_KD.R')
>>>>>>> eb627a0fbdfa9518fc6f8f80df611e8bbd227940
