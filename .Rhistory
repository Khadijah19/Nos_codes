<<<<<<< HEAD
if (! chosen_col %in% names(entity_data)) {
showNotification(
"La colonne demandée n’existe pas dans les données pour ce niveau.",
type = "error"
)
return(leaflet() %>% addTiles())
}
pal <- colorNumeric("viridis",
domain   = range(entity_data[[chosen_col]], na.rm = TRUE),
na.color = "transparent")
name_col <- switch(
input$admin_level,
"Région"      = "ADM1_FR",
"Département" = "ADM2_FR",
"Commune"     = "ADM3_FR"
)
leaflet(entity_data) %>%
addTiles() %>%
addPolygons(
fillColor       = ~ pal(get(chosen_col)),
fillOpacity     = 0.7,
color           = "white",
weight          = 2,
highlightOptions= highlightOptions(
weight = 3,
color  = "#666",
fillOpacity = 0.9,
bringToFront = TRUE
),
label = ~paste0(
input$admin_level, " : ", get(name_col),
" ; ", indic, " : ", round(get(chosen_col), 3)
),
labelOptions = labelOptions(
style = list(
"font-weight"       = "bold",
"color"             = "#666",
"background-color"  = "rgba(255,255,255,0.8)",
"border"            = "1px solid #ccc",
"border-radius"     = "4px",
"padding"           = "4px"
),
textsize  = "13px",
direction = "auto"
)
) %>%
addLegend(
position = "bottomright",
pal      = pal,
values   = entity_data[[chosen_col]],
title    = paste(indic, "(", input$admin_level, ")")
)
}
})
})
}
# ─────────────────────────────────────────────────────────────────────────────
# mod_notes_techniques_page_KD.R
# Page "Notes Techniques"
# ─────────────────────────────────────────────────────────────────────────────
mod_notes_techniques_page_ui <- function(id) {
ns <- NS(id)
fluidPage(
useShinyjs(),  # Activate shinyjs for toggle functionality
fluidRow(
column(
12,
tags$h2("Au delà des indicateurs"),
tags$hr(),
# Section 1 - Taux moyen de malaria entre 2000 et 2022
tags$div(style="background:#f0f0f0; padding:10px;",
actionButton(ns("btn1"), label = "Taux moyen de malaria entre 2000 et 2022", class = "btn-primary"),
hidden(div(id = ns("details1"),
tags$ul(
tags$li("Ce qu'il faut savoir"),
tags$p("Le taux moyen de malaria, calculé ici sur une période de 22 ans (2000-2022), permet de suivre l'évolution de la prévalence de cette maladie infectieuse dans une région donnée sur trois niveaux administratifs (pays, région, département, commune)."),
tags$p("Le paludisme, également connu sous le nom de 'fièvre des marais', est causé par un parasite du genre Plasmodium et transmis par les piqûres de moustiques femelles du genre Anopheles. Malgré les progrès réalisés, cette maladie demeure un défi majeur de santé publique, en particulier dans les régions tropicales et subtropicales.")
),
tags$ul(
tags$li("Derrière les chiffres : comment calculer cet indicateur ?"),
tags$p("Pour une compréhension de la méthodologie de calcul, vous pouvez consulter le TP4 du projet 'Statistique-Exploratoire-Spatiale' disponible sur GitHub avec 4 logiciels GEE with Python, GEE with JavaScript, R, Python :"),
tags$a("Lien vers TP4", href="https://github.com/Abson-dev/Statistique-Exploratoire-Spatiale/tree/main/TP4", target="_blank")
),
tags$ul(
tags$li("En savoir plus"),
tags$p("Le Malaria Atlas Project (MAP) est une initiative qui compile et fournit des données détaillées sur la distribution du paludisme à l'échelle mondiale. Le MAP propose un package R, nommé malariaAtlas :"),
tags$a("CRAN: Package malariaAtlas", href="https://cran.r-project.org/web/packages/malariaAtlas/index.html", target="_blank"),
tags$p("Ce package permet aux chercheurs et aux professionnels de la santé de télécharger et d'analyser des données ouvertes sur le paludisme, y compris des points d'enquête sur les taux de parasites, des occurrences de moustiques vecteurs et des surfaces raster modélisées. Ce package facilite l'intégration de ces données dans des analyses spatiales et temporelles pour une meilleure compréhension de la dynamique du paludisme."),
tags$p("Pour plus d'informations sur le Malaria Atlas Project et pour accéder à leurs ressources, visitez leur site officiel :"),
tags$a("Malaria Atlas Project | Home", href="https://malariaatlas.org/", target="_blank")
),
)
)
),
# Section 2 - Taux de malaria chez les enfants en 2022
tags$div(style="background:#f0f0f0; padding:10px;",
actionButton(ns("btn2"), label = "Taux de malaria chez les enfants en 2022", class = "btn-primary"),
hidden(div(id = ns("details2"),
tags$ul(
tags$li("Ce qu'il faut savoir"),
tags$p("Cet indicateur mesure la prévalence de la malaria chez les enfants de moins de 5 ans en 2022. Le taux de malaria chez les enfants, particulièrement ceux de moins de 5 ans, est un indicateur clé de la vulnérabilité des populations face à cette maladie. En 2013, un enfant mourrait chaque minute du paludisme en Afrique, soulignant l’ampleur de cette crise sanitaire."),
tags$p("En 2022, la région africaine a enregistré 233 millions de cas de paludisme, causant 580 000 décès soit 94 % des cas et 95 % des décès liés au paludisme dans le monde. Bien que ce chiffre représente une légère baisse par rapport à 2021, les enfants de moins de 5 ans continuent d’être les plus touchés, représentant environ 78 % des décès liés au paludisme. (Site officiel de l’OMS)")
),
tags$ul(
tags$li("Derrière les chiffres : comment calculer cet indicateur ?"),
tags$p("Pour une compréhension de la méthodologie de calcul, vous pouvez consulter le TP5 du projet 'Statistique-Exploratoire-Spatiale' disponible sur GitHub avec 4 logiciels GEE with Python, GEE with JavaScript, R, Python :"),
tags$a("Lien vers TP5", href="https://github.com/Abson-dev/Statistique-Exploratoire-Spatiale/tree/main/TP5", target="_blank")
),
tags$ul(
tags$li("En savoir plus : Saviez-vous qu’il existe un journal scientifique dédié exclusivement au paludisme ? "),
tags$p("Le Malaria Journal est une source précieuse pour les chercheurs et décideurs. Un article particulièrement intéressant explore la distribution estimée des cas de malaria parmi les enfants en Afrique subsaharienne en fonction de catégories d'âge spécifiques, à partir des données du Global Burden of Diseases 2019. Lien vers l’article "),
tags$a("Malaria Journal - Estimated distribution of malaria cases among children.", href="https://malariajournal.biomedcentral.com/articles/10.1186/s12936-023-04811-z", target="_blank"),
),
)
)
),
# Section 3 - Conflict Diffusion Indicator
tags$div(style="background:#f0f0f0; padding:10px;",
actionButton(ns("btn3"), label = "Conflict Diffusion Indicator", class = "btn-primary"),
hidden(div(id = ns("details3"),
tags$ul(
tags$li("Ce qu'il faut savoir"),
tags$p("Le Conflict Diffusion Indicator (CDI) mesure l’extension géographique et temporelle des conflits à travers les régions. Cet indicateur permet de suivre comment un conflit initialement localisé peut se propager à d’autres zones, soit par effet de contagion, soit à travers des dynamiques socio-politiques ou géographiques.L’histoire récente des hommes est marquée par un XXème siècle caractérisé, notamment dans sa première moitié, par des conflits de dimensions internationales aux conséquences sociales, économiques et humaines désastreuses. L’humanité a entamé sa marche vers le 3ème millénaire par une série de conflits certes de plus faibles dimensions, puisqu’impliquant moins d’Etats et aux origines internes avec généralement une combinaison des soubassements à la fois politiques, économiques et sociétales. (La modélisation de la relation entre démographie, paix et sécurité, UNFPA ONU)"),
tags$p("Le CDI est donc essentiel pour comprendre la nature des conflits modernes, qui sont souvent influencés par des variables complexes telles que la proximité des frontières, les divisions ethniques ou religieuses, et les vulnérabilités socio-économiques.")
),
tags$ul(
tags$li("Derrière les chiffres : comment calculer cet indicateur ?"),
tags$p("Pour une compréhension de la méthodologie de calcul, vous pouvez consulter le TP6 du projet 'Statistique-Exploratoire-Spatiale' disponible sur GitHub avec 4 logiciels GEE with Python, GEE with JavaScript, R, Python :"),
tags$a("Lien vers TP6", href="https://github.com/Abson-dev/Statistique-Exploratoire-Spatiale/tree/main/TP6", target="_blank")
),
tags$ul(
tags$li("En savoir plus:« Bringing clarity to crisis », à la découverte de ACLED"),
tags$p("L’Armed Conflict Location & Event Data Project (ACLED) constitue une ressource essentielle pour l’analyse des dynamiques de conflits et de violence politique à l’échelle mondiale. Ses bases de données fournissent des informations détaillées sur les localisations des incidents, les types d’événements, les acteurs impliqués, ainsi que leurs évolutions temporelles. ACLED s’impose comme un outil indispensable pour les chercheurs, décideurs et analystes souhaitant mieux comprendre les zones de tension, anticiper les tendances, ou cartographier les conflits. Pour explorer ces données essentielles : "),
tags$a("ACLED (Armed Conflict Location and Event Data)", href="https://acleddata.com/", target="_blank")
),
)
)
),
# Section 4 - NDVI
tags$div(style="background:#f0f0f0; padding:10px;",
actionButton(ns("btn4"), label = "NDVI (Normalized Difference Vegetation Index)", class = "btn-primary"),
hidden(div(id = ns("details4"),
tags$ul(
tags$li("Ce qu'il faut savoir"),
tags$p("Le Normalized Difference Vegetation Index (NDVI), ou Indice de Végétation par Différence Normalisée, est un indicateur spectral clé en télédétection, utilisé pour évaluer la présence et la santé de la végétation verte. Cet indice, allant de -1 à +1, est calculé à partir des valeurs de réflectance dans les longueurs d'onde rouge et proche infra-rouge.Les valeurs négatives indiquent généralement la présence d’eau.Celles proches de zéro reflètent des surfaces urbaines ou dépourvues de végétation.Enfin les valeurs proches de +1 : Sont caractéristiques d’une végétation dense et saine."),
tags$p("Le NDVI est particulièrement prisé pour sa capacité à surveiller la dynamique de la végétation sur de vastes territoires et sur de longues périodes. Selon la NASA, le NDVI est un indicateur fiable pour identifier les périodes de sécheresse, car une végétation stressée par le manque d’eau affichera des valeurs NDVI plus faibles.")
),
tags$ul(
tags$li("Derrière les chiffres : comment calculer cet indicateur ?"),
tags$p("Pour une compréhension de la méthodologie de calcul, vous pouvez consulter le TP10 du projet 'Statistique-Exploratoire-Spatiale' disponible sur GitHub avec 4 logiciels GEE with Python, GEE with JavaScript, R, Python :"),
tags$a("Lien vers TP10", href="https://github.com/Abson-dev/Statistique-Exploratoire-Spatiale/tree/main/TP10", target="_blank")
),
tags$ul(
tags$li("En savoir plus : Exploration du NDVI (Du spectre lumineux à la chlorophylle)"),
tags$p("Le NDVI (Normalized Difference Vegetation Index) est calculé en utilisant la réflectance mesurée dans deux bandes spécifiques du spectre électromagnétique : le proche infra-rouge (NIR ou Near Infra Red) et la lumière rouge (Red). Ces deux longueurs d’onde jouent un rôle clé dans l’analyse de la végétation. Les plantes saines, riches en chlorophylle, absorbent fortement la lumière rouge pour la photosynthèse, tout en réfléchissant une grande quantité de lumière proche infra-rouge grâce à la structure cellulaire de leurs feuilles. Cela explique pourquoi nous percevons les plantes comme vertes : elles renvoient plus de lumière verte que de lumière rouge ou bleue. Si nous pouvions voir dans le spectre du proche infra-rouge, la végétation apparaîtrait encore plus brillante, car elle réfléchit intensément cette longueur d’onde. Ce contraste entre l’absorption de la lumière rouge et la réflexion du proche infra-rouge est la base du calcul du NDVI, qui permet d’évaluer la santé et la densité de la végétation de manière standardisée et précise. Pour approfondir vos connaissances, consultez "),
tags$a("NDVI (indice de végétation par différence normalisée) et PRI (indice de réflectance photochimique) - Le guide complet du chercheur - METER Group.", href="https://metergroup.com/fr/education-guides/ndvi-and-pri-the-researchers-complete-guide/", target="_blank"),
),
)
)
),
# Section 5 - NDBI
tags$div(style="background:#f0f0f0; padding:10px;",
actionButton(ns("btn5"), label = "NDBI (Normalized Difference Built-up Index)", class = "btn-primary"),
hidden(div(id = ns("details5"),
tags$ul(
tags$li("Ce qu'il faut savoir"),
tags$p("L'Indice Différentiel Normalisé des Zones Bâties (NDBI - Normalized Difference Built-up Index) est un indice dérivé d’images satellites, qui utilise les bandes Proche Infrarouge (NIR) et Infrarouge à Ondes Courtes (SWIR)."),
tags$p("Il permet de mettre en évidence les zones urbaines et bâties. Sa formule basée sur un ratio réduit les effets des variations d’illumination du terrain ainsi que des conditions atmosphériques, ce qui en fait un outil fiable pour analyser les dynamiques d’urbanisation.")
),
tags$ul(
tags$li("Derrière les chiffres : comment calculer cet indicateur ?"),
tags$p("Pour une compréhension de la méthodologie de calcul, vous pouvez consulter le TP10 du projet 'Statistique-Exploratoire-Spatiale' disponible sur GitHub avec 4 logiciels GEE with Python, GEE with JavaScript, R, Python :"),
tags$a("Lien vers TP10", href="https://github.com/Abson-dev/Statistique-Exploratoire-Spatiale/tree/main/TP10", target="_blank")
),
tags$ul(
tags$li("En savoir plus : les avantages et incovénients du NDBI"),
tags$p("Le NDBI (Normalized Difference Built-up Index) est un outil efficace pour cartographier les zones bâties, grâce à sa simplicité et à sa capacité à réduire les biais liés à l’éclairage et aux conditions atmosphériques grace à sa formule basée sur le rapport SWIR/NIR. Il est largement utilisé avec des images satellitaires gratuites comme Landsat et Sentinel-2. Cependant, il peut confondre certaines surfaces bâties avec des sols nus et sa précision dépend de la résolution des données. Pour des analyses plus fiables, il est souvent complété par d'autres indices comme le NDVI."),
tags$a("NDBI—ArcGIS Pro | Documentation", href="https://pro.arcgis.com/en/pro-app/latest/arcpy/spatial-analyst/ndbi.htm", target="_blank"),
)
)
)
),
)
)
)
}
mod_notes_techniques_page_server <- function(id) {
moduleServer(id, function(input, output, session) {
# Toggles for each section
observeEvent(input$btn1, {
toggle("details1")
})
observeEvent(input$btn2, {
toggle("details2")
})
observeEvent(input$btn3, {
toggle("details3")
})
observeEvent(input$btn4, {
toggle("details4")
})
observeEvent(input$btn5, {
toggle("details5")
})
})
}
# ─────────────────────────────────────────────────────────────────────────────
# mod_state_filter_page_KD.R
# Module 4 : Sélection d’une Région, puis onglets Résumé, Tableau, Graphique
# + Téléchargements
# ─────────────────────────────────────────────────────────────────────────────
mod_state_filter_page_ui <- function(id){
ns <- NS(id)
fluidPage(
# Le module n’apparaît que si le pays ET l’indicateur sont sélectionnés
conditionalPanel(
condition = sprintf("input['landing_page-country'] !== '' && input['landing_page-indicator_chosen'] !== ''"),
fluidRow(
column(
width = 3,
# Liste dynamique des régions (on mettra à jour dans le server)
selectInput(ns("region"), "Sélectionnez une Région :",
choices = c("")),
selectInput(ns("signif"), "Filtrer par Quartile :",
choices = c("Afficher tout", "0-25%", "25-50%", "50-75%", "75-100%")),
helpText("Les données affichées peuvent être filtrées selon la fourchette de valeurs.")
),
column(
width = 9,
# Afficher la suite uniquement si on a choisi une région
conditionalPanel(
condition = sprintf("input['%s'] != ''", ns("region")),
div(
class = "dark-box",
div(
class = "red-title-box",
textOutput(ns("selected_indicator_title"))
),
div(
class = "red-title-box",
textOutput(ns("selected_region_title"))
),
p("Nous présentons ci-dessous les statistiques résumées par région ",
"pour l'indicateur sélectionné.")
),
tabsetPanel(
# --- Onglet Résumé ---
tabPanel(
title = "Résumé",
br(),
# Bouton de téléchargement pour le tableau résumé
downloadButton(ns("download_resume_table"), "Télécharger le résumé (CSV)"),
tableOutput(ns("resume_table")),
hr(),
textOutput(ns("resume_comment"))
),
# --- Onglet Tableau ---
tabPanel(
title = "Tableau",
br(),
h4("Tableau des Départements"),
downloadButton(ns("download_dep_table"), "Télécharger (CSV)"),
tableOutput(ns("dep_table")),
h4("Tableau des Communes"),
downloadButton(ns("download_com_table"), "Télécharger (CSV)"),
tableOutput(ns("com_table")),
hr(),
textOutput(ns("table_comment"))
),
# --- Onglet Graphique ---
tabPanel(
title = "Graphique",
br(),
plotOutput(ns("dep_plot"), height = "300px"),
downloadButton(ns("download_dep_plot"), "Télécharger Graphique Départements (PNG)"),
plotOutput(ns("com_plot"), height = "300px"),
downloadButton(ns("download_com_plot"), "Télécharger Graphique Communes (PNG)")
)
)
)
)
)
)
)
}
mod_state_filter_page_server <- function(id, landing_inputs, indicator_chosen_) {
moduleServer(id, function(input, output, session) {
data_reac <- reactive({ landing_inputs() })
# 1) Mettre à jour la liste de régions dès que data_global$regions est modifié (multi-pays)
observeEvent(data_global$regions, {
req(data_global$regions)
region_choices <- sort(unique(data_global$regions$ADM1_FR))
updateSelectInput(
session, "region",
choices = c("", region_choices),
selected = ""
)
})
# 2) Titres
output$selected_indicator_title <- renderText({
req(data_reac()$indicator_chosen)
paste("Indicateur sélectionné :", data_reac()$indicator_chosen)
})
output$selected_region_title <- renderText({
req(input$region)
paste("Région sélectionnée :", input$region)
})
# 3) Fonction pour la fourchette
# 4) Colonne selon l’indicateur
chosen_col <- reactive({
switch(
data_reac()$indicator_chosen,
"Taux moyen de Paludisme"          = "mean_index",
"Taux de malaria chez les enfants" = "taux_malaria_enfants",
"NDVI"                             = "mean_ndvi",
"CDI"= "CDI",
"NDBI" = "mean_ndbi",
NULL
)
})
validate_chosen_col <- reactive({
if (is.null(chosen_col())) {
showNotification("Aucun indicateur valide n'est sélectionné.", type = "error")
stop("Colonne choisie NULL.")
}
chosen_col()
})
# Fonction pour calculer les bornes des quantiles
getQuantileRange <- function(data, signif_str, chosen_col) {
# Si aucun filtre n'est appliqué (Afficher tout)
if (signif_str == "Afficher tout") {
return(c(-Inf, Inf))
}
# Calcul des quantiles sur la colonne sélectionnée
quantiles <- quantile(data[[chosen_col]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)
# Retourner les bornes correspondant au choix
if (signif_str == "0-25%") return(c(quantiles[1], quantiles[2]))
if (signif_str == "25-50%") return(c(quantiles[2], quantiles[3]))
if (signif_str == "50-75%") return(c(quantiles[3], quantiles[4]))
if (signif_str == "75-100%") return(c(quantiles[4], quantiles[5]))
# Valeur par défaut (en cas de problème)
return(c(-Inf, Inf))
}
# 5) Filtrage
deps_filtered <- reactive({
req(input$region, validate_chosen_col())
minmax <- getQuantileRange(data_global$departments, input$signif, chosen_col())
data_global$departments %>%
filter(
ADM1_FR == input$region,
.data[[chosen_col()]] >= minmax[1],
.data[[chosen_col()]] <= minmax[2]
)
})
coms_filtered <- reactive({
req(input$region, validate_chosen_col())
minmax <- getQuantileRange(data_global$communes, input$signif, chosen_col())
data_global$communes %>%
filter(
ADM1_FR == input$region,
.data[[chosen_col()]] >= minmax[1],
.data[[chosen_col()]] <= minmax[2]
)
})
# 6) Tableau Résumé
summary_table_reactive <- reactive({
req(input$region, validate_chosen_col())
dep_vals <- deps_filtered()[[chosen_col()]]
com_vals <- coms_filtered()[[chosen_col()]]
reg_val <- data_global$regions %>%
filter(ADM1_FR == input$region) %>%
pull(chosen_col())
data.frame(
row.names = c("Moyenne", "Maximum", "Minimum"),
"Région"      = c(
round(mean(reg_val, na.rm = TRUE), 3),
round(max(reg_val, na.rm = TRUE), 3),
round(min(reg_val, na.rm = TRUE), 3)
),
"Département" = c(
round(mean(dep_vals, na.rm = TRUE), 3),
round(max(dep_vals, na.rm = TRUE), 3),
round(min(dep_vals, na.rm = TRUE), 3)
),
"Commune"     = c(
round(mean(com_vals, na.rm = TRUE), 3),
round(max(com_vals, na.rm = TRUE), 3),
round(min(com_vals, na.rm = TRUE), 3)
)
)
})
output$resume_table <- renderTable({
summary_table_reactive()
}, rownames = TRUE)
output$resume_comment <- renderText({
"Interprétation : ce tableau compare la valeur régionale et les valeurs des départements/communes filtrés."
})
# *** Téléchargement du tableau Résumé ***
output$download_resume_table <- downloadHandler(
filename = function(){
paste0("resume_table_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(summary_table_reactive(), file, row.names = TRUE)
}
)
# 7) Tableaux départements / communes
output$dep_table <- renderTable({
req(input$region, validate_chosen_col())
df <- deps_filtered()
data.frame(
Departement = df$ADM2_FR,
Taux = round(df[[chosen_col()]], 3)
)
})
output$com_table <- renderTable({
req(input$region, validate_chosen_col())
df <- coms_filtered()
data.frame(
Commune = df$ADM3_FR,
Taux = round(df[[chosen_col()]], 3)
)
})
output$table_comment <- renderText({
"Tableaux listant les départements et communes respectant le filtre choisi."
})
# Téléchargements CSV pour Départements / Communes
output$download_dep_table <- downloadHandler(
filename = function(){
paste0("departements_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(deps_filtered(), file, row.names = FALSE)
}
)
output$download_com_table <- downloadHandler(
filename = function(){
paste0("communes_", input$region, "_", Sys.Date(), ".csv")
},
content = function(file){
write.csv(coms_filtered(), file, row.names = FALSE)
}
)
# 8) Graphiques Départements / Communes
output$dep_plot <- renderPlot({
req(input$region, validate_chosen_col())
df <- deps_filtered()
ggplot(df, aes(x = ADM2_FR, y = .data[[chosen_col()]], group = 1)) +
geom_bar(stat = "identity", fill = "skyblue", color = "black") +
theme_minimal() +
labs(title = "Taux par Département", x = "Département", y = "Valeur") +
theme(panel.background = element_rect(fill = "white", color = NA),
plot.background = element_rect(fill = "white", color = NA),
axis.text.x = element_text(angle = 45, hjust = 1))
})
output$com_plot <- renderPlot({
req(input$region, validate_chosen_col())
df <- coms_filtered()
ggplot(df, aes(x = ADM3_FR, y = .data[[chosen_col()]], group = 1)) +
geom_bar(stat = "identity", fill = "skyblue", color = "black")+
theme_minimal() +
labs(title = "Taux par Commune", x = "Commune", y = "Valeur") +
theme(panel.background = element_rect(fill = "white", color = NA),
plot.background = element_rect(fill = "white", color = NA),
axis.text.x = element_text(angle = 45, hjust = 1))
})
# Téléchargements PNG pour Départements / Communes
output$download_dep_plot <- downloadHandler(
filename = function() {
paste0("graphique_departements_", input$region, "_", Sys.Date(), ".png")
},
content = function(file) {
df <- deps_filtered()
p <- ggplot(df, aes(x = ADM2_FR, y = .data[[chosen_col()]])) +
geom_bar(stat = "identity", fill = "skyblue", color = "black")+
theme_minimal() +
labs(title = "Graphique par Département", x = "Département", y = "Valeur")
ggsave(file, plot = p, device = "png", width = 10, height = 6, bg = "white")
}
)
output$download_com_plot <- downloadHandler(
filename = function() {
paste0("graphique_communes_", input$region, "_", Sys.Date(), ".png")
},
content = function(file) {
df <- coms_filtered()
p <- ggplot(df, aes(x = ADM3_FR, y = .data[[chosen_col()]])) +
geom_bar(stat = "identity", fill = "skyblue", color = "black") +
theme_minimal() +
labs(title = "Graphique par Commune", x = "Commune", y = "Valeur")
ggsave(file, plot = p, device = "png", width = 10, height = 6, bg = "white")
}
)
})
}
# ─────────────────────────────────────────────────────────────────────────────
# app.R
# Fichier principal
# ─────────────────────────────────────────────────────────────────────────────
# 1) Charger les scripts R
source("global_KD.R")                 # global
# 1) Charger les scripts R
source("global_KD.R")                 # global
# ─────────────────────────────────────────────────────────────────────────────
# app.R
# Fichier principal
# ─────────────────────────────────────────────────────────────────────────────
# 1) Charger les scripts R
source("global_KD.R")                 # global
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
=======
# Calculs pour les niveaux administratifs
regions$mean_index <- exact_extract(mean_raster, regions, 'mean')
regions$mean_ndvi <- exact_extract(ndvi_raster, regions, 'mean')
regions$mean_ndbi <- exact_extract(ndbi_raster, regions, 'mean')
regions$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, regions, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, regions, 'sum') / exact_extract(raster_pop_enfants, regions, 'sum'),
NA
)
departments$mean_index <- exact_extract(mean_raster, departments, 'mean')
departments$mean_ndvi <- exact_extract(ndvi_raster, departments, 'mean')
departments$mean_ndbi <- exact_extract(ndbi_raster, departments, 'mean')
departments$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, departments, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, departments, 'sum') / exact_extract(raster_pop_enfants, departments, 'sum'),
NA
)
communes$mean_index <- exact_extract(mean_raster, communes, 'mean')
communes$mean_ndvi <- exact_extract(ndvi_raster, communes, 'mean')
communes$mean_ndbi <- exact_extract(ndbi_raster, communes, 'mean')
communes$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, communes, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, communes, 'sum') / exact_extract(raster_pop_enfants, communes, 'sum'),
NA
)
# Calcul CDI pour chaque niveau
pop_count_regions <- exact_extract(pop_resampled_binary, regions, 'sum')
prod_count_regions <- exact_extract(mult_raster, regions, 'sum')
regions$CDI <- ifelse(pop_count_regions > 0, prod_count_regions / pop_count_regions, NA)
pop_count_departments <- exact_extract(pop_resampled_binary, departments, 'sum')
prod_count_departments <- exact_extract(mult_raster, departments, 'sum')
departments$CDI <- ifelse(pop_count_departments > 0, prod_count_departments / pop_count_departments, NA)
pop_count_communes <- exact_extract(pop_resampled_binary, communes, 'sum')
prod_count_communes <- exact_extract(mult_raster, communes, 'sum')
communes$CDI <- ifelse(pop_count_communes > 0, prod_count_communes / pop_count_communes, NA)
calculer_indicateurs(donnees)
chemin_sauvegarde <- file.path(chemin_base, "Senegal", "Shapefiles_Optimises")
if (!dir.exists(chemin_sauvegarde)) {
dir.create(chemin_sauvegarde, recursive = TRUE)
}
# Sauvegarde en GeoJSON (lisible avec QGIS, R, Python, etc.)
st_write(regions, file.path(chemin_sauvegarde, paste0("regions.shp")), delete_dsn = TRUE)
st_write(departments, file.path(chemin_sauvegarde, paste0("departments.shp")), delete_dsn = TRUE)
st_write(communes, file.path(chemin_sauvegarde, paste0("communes.shp")), delete_dsn = TRUE)
donnees <- charger_donnees_pays("Burkina")
regions <- donnees$regions
departments <- donnees$departments
communes <- donnees$communes
mean_raster <- donnees$mean_raster
raster_nombre_malaria_enfants <- donnees$raster_nombre_malaria_enfants
raster_pop_enfants <- donnees$raster_pop_enfants
ndvi_raster <- donnees$ndvi_raster
ndbi_raster <- donnees$ndbi_raster
pop_resampled_binary <- donnees$pop_resampled_binary
mult_raster <- donnees$mult_raster
# Calculs pour les niveaux administratifs
regions$mean_index <- exact_extract(mean_raster, regions, 'mean')
regions$mean_ndvi <- exact_extract(ndvi_raster, regions, 'mean')
regions$mean_ndbi <- exact_extract(ndbi_raster, regions, 'mean')
regions$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, regions, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, regions, 'sum') / exact_extract(raster_pop_enfants, regions, 'sum'),
NA
)
departments$mean_index <- exact_extract(mean_raster, departments, 'mean')
departments$mean_ndvi <- exact_extract(ndvi_raster, departments, 'mean')
departments$mean_ndbi <- exact_extract(ndbi_raster, departments, 'mean')
departments$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, departments, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, departments, 'sum') / exact_extract(raster_pop_enfants, departments, 'sum'),
NA
)
communes$mean_index <- exact_extract(mean_raster, communes, 'mean')
communes$mean_ndvi <- exact_extract(ndvi_raster, communes, 'mean')
communes$mean_ndbi <- exact_extract(ndbi_raster, communes, 'mean')
communes$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, communes, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, communes, 'sum') / exact_extract(raster_pop_enfants, communes, 'sum'),
NA
)
# Calcul CDI pour chaque niveau
pop_count_regions <- exact_extract(pop_resampled_binary, regions, 'sum')
prod_count_regions <- exact_extract(mult_raster, regions, 'sum')
regions$CDI <- ifelse(pop_count_regions > 0, prod_count_regions / pop_count_regions, NA)
pop_count_departments <- exact_extract(pop_resampled_binary, departments, 'sum')
prod_count_departments <- exact_extract(mult_raster, departments, 'sum')
departments$CDI <- ifelse(pop_count_departments > 0, prod_count_departments / pop_count_departments, NA)
pop_count_communes <- exact_extract(pop_resampled_binary, communes, 'sum')
prod_count_communes <- exact_extract(mult_raster, communes, 'sum')
communes$CDI <- ifelse(pop_count_communes > 0, prod_count_communes / pop_count_communes, NA)
chemin_sauvegarde <- file.path(chemin_base, "Burkina", "Shapefiles_Optimises")
if (!dir.exists(chemin_sauvegarde)) {
dir.create(chemin_sauvegarde, recursive = TRUE)
}
# Sauvegarde en GeoJSON (lisible avec QGIS, R, Python, etc.)
st_write(regions, file.path(chemin_sauvegarde, paste0("regions.shp")), delete_dsn = TRUE)
st_write(departments, file.path(chemin_sauvegarde, paste0("departments.shp")), delete_dsn = TRUE)
st_write(communes, file.path(chemin_sauvegarde, paste0("communes.shp")), delete_dsn = TRUE)
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
library(shiny); runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
donnees <- charger_donnees_pays("Senegal")
donnees <- charger_donnees_pays("Senegal")
# ─────────────────────────────────────────────────────────────────────────────────
# global.R : Gestion des données multi-pays avec calculs et chargement des rasters
# ─────────────────────────────────────────────────────────────────────────────────
# 1) Chargement des bibliothèques nécessaires
library(shiny)
library(shinyjs)
library(leaflet)
library(dplyr)
library(ggplot2)
library(sf)
library(raster)
library(exactextractr)
library(viridis)
# 2) Définition des indicateurs par pays
fake_indicators <- list(
"Senegal" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants","CDI", "NDVI", "NDBI"),
"Burkina" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants", "CDI", "NDVI", "NDBI")
)
# 3) Définition des fichiers shapefile par pays
shapefile_noms <- list(
"Senegal" = list(
adm0 = "sen_admbnda_adm0_anat_20240520.shp",
adm1 = "sen_admbnda_adm1_anat_20240520.shp",
adm2 = "sen_admbnda_adm2_anat_20240520.shp",
adm3 = "sen_admbnda_adm3_anat_20240520.shp"
),
"Burkina" = list(
adm0 = "bfa_admbnda_adm0_igb_20200323.shp",
adm1 = "bfa_admbnda_adm1_igb_20200323.shp",
adm2 = "bfa_admbnda_adm2_igb_20200323.shp",
adm3 = "bfa_admbnda_adm3_igb_20200323.shp"
)
)
chemin_base <- "../data"
# 4) Fonction pour charger les données pour un pays donné
charger_donnees_pays <- function(pays) {
shapefile_path <- file.path(chemin_base, pays, "Shapefiles")
raster_path <- file.path(chemin_base, pays, "Rasters")
noms <- shapefile_noms[[pays]]
# Chargement des shapefiles
regions <- st_read(file.path(shapefile_path, noms$adm1), quiet = TRUE)
departments <- st_read(file.path(shapefile_path, noms$adm2), quiet = TRUE)
communes <- st_read(file.path(shapefile_path, noms$adm3), quiet = TRUE)
# Chargement des rasters
#Chargement des rasters en batch
raster_path <- file.path(chemin_base,pays, "Rasters")
fichiers_raster <- list.files(raster_path, pattern = "\\.tiff$", full.names = TRUE)
rasters <- stack(fichiers_raster)
#Calcul du raster moyen (mean_raster)
mean_raster <- calc(rasters, fun = mean, na.rm = TRUE)
raster_nombre_malaria_enfants <- raster(file.path(raster_path, "malaria_enfants/raster_nombre_malaria_enfants.tif"))
raster_pop_enfants <- raster(file.path(raster_path, "malaria_enfants/raster_pop_enfants.tif"))
ndvi_raster <- raster(file.path(raster_path, paste0("Indices_spectraux/NDVI_", pays, ".tif")))
ndbi_raster<- raster(file.path(raster_path, paste0("Indices_spectraux/NDBI_", pays, ".tif")))
pop_resampled_binary<- raster(file.path(raster_path,"CDI/pop_resampled_binary.tif"))
mult_raster <- raster(file.path(raster_path, "CDI/mult_raster.tif"))
list(
regions = regions,
departments = departments,
communes = communes,
mean_raster = mean_raster,
raster_nombre_malaria_enfants = raster_nombre_malaria_enfants,
raster_pop_enfants = raster_pop_enfants,
ndvi_raster = ndvi_raster,
ndbi_raster = ndbi_raster,
pop_resampled_binary = pop_resampled_binary,
mult_raster = mult_raster
)
}
# 5) Calculs par niveau administratif
calculer_indicateurs <- function(donnees) {
regions <- donnees$regions
departments <- donnees$departments
communes <- donnees$communes
mean_raster <- donnees$mean_raster
raster_nombre_malaria_enfants <- donnees$raster_nombre_malaria_enfants
raster_pop_enfants <- donnees$raster_pop_enfants
ndvi_raster <- donnees$ndvi_raster
ndbi_raster <- donnees$ndbi_raster
pop_resampled_binary <- donnees$pop_resampled_binary
mult_raster <- donnees$mult_raster
# Calculs pour les niveaux administratifs
regions$mean_index <- exact_extract(mean_raster, regions, 'mean')
regions$mean_ndvi <- exact_extract(ndvi_raster, regions, 'mean')
regions$mean_ndbi <- exact_extract(ndbi_raster, regions, 'mean')
regions$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, regions, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, regions, 'sum') / exact_extract(raster_pop_enfants, regions, 'sum'),
NA
)
departments$mean_index <- exact_extract(mean_raster, departments, 'mean')
departments$mean_ndvi <- exact_extract(ndvi_raster, departments, 'mean')
departments$mean_ndbi <- exact_extract(ndbi_raster, departments, 'mean')
departments$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, departments, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, departments, 'sum') / exact_extract(raster_pop_enfants, departments, 'sum'),
NA
)
communes$mean_index <- exact_extract(mean_raster, communes, 'mean')
communes$mean_ndvi <- exact_extract(ndvi_raster, communes, 'mean')
communes$mean_ndbi <- exact_extract(ndbi_raster, communes, 'mean')
communes$taux_malaria_enfants <- ifelse(
exact_extract(raster_pop_enfants, communes, 'sum') > 0,
exact_extract(raster_nombre_malaria_enfants, communes, 'sum') / exact_extract(raster_pop_enfants, communes, 'sum'),
NA
)
# Calcul CDI pour chaque niveau
pop_count_regions <- exact_extract(pop_resampled_binary, regions, 'sum')
prod_count_regions <- exact_extract(mult_raster, regions, 'sum')
regions$CDI <- ifelse(pop_count_regions > 0, prod_count_regions / pop_count_regions, NA)
pop_count_departments <- exact_extract(pop_resampled_binary, departments, 'sum')
prod_count_departments <- exact_extract(mult_raster, departments, 'sum')
departments$CDI <- ifelse(pop_count_departments > 0, prod_count_departments / pop_count_departments, NA)
pop_count_communes <- exact_extract(pop_resampled_binary, communes, 'sum')
prod_count_communes <- exact_extract(mult_raster, communes, 'sum')
communes$CDI <- ifelse(pop_count_communes > 0, prod_count_communes / pop_count_communes, NA)
list(
regions = regions,
departments = departments,
communes = communes
)
}
# 6) Variables réactives pour stocker les données
data_global <- reactiveValues(
regions = NULL,
departments = NULL,
communes = NULL,
mean_raster = NULL,
raster_nombre_malaria_enfants = NULL,
raster_pop_enfants = NULL,
ndvi_raster = NULL,
ndbi_raster = NULL,
pop_resampled_binary = NULL,
mult_raster = NULL
)
# 7) Fonction pour mettre à jour les données globales
update_data_global <- function(pays) {
donnees <- charger_donnees_pays(pays)
resultats <- calculer_indicateurs(donnees)
data_global$regions <- resultats$regions
data_global$departments <- resultats$departments
data_global$communes <- resultats$communes
data_global$mean_raster <- donnees$mean_raster
data_global$raster_nombre_malaria_enfants <- donnees$raster_nombre_malaria_enfants
data_global$raster_pop_enfants <- donnees$raster_pop_enfants
data_global$ndvi_raster <- donnees$ndvi_raster
data_global$ndbi_raster <- donnees$ndbi_raster
data_global$pop_resampled_binary <- donnees$pop_resampled_binary
data_global$mult_raster <- donnees$mult_raster
message("Données mises à jour pour le pays : ", pays)
}
# ─────────────────────────────────────────────────────────────────────────────────
runApp('Scripts R KD/app_KD.R')
runApp('Scripts R KD/app_KD.R')
donnee<- charger_donnees_pays("Senegal")
# ─────────────────────────────────────────────────────────────────────────────────
# global.R : Gestion des données multi-pays avec calculs et chargement des rasters
# Utilisation de shapefiles (.shp) et non de RDS
# ─────────────────────────────────────────────────────────────────────────────────
# 1) Chargement des bibliothèques nécessaires
library(shiny)
library(shinyjs)
library(leaflet)
library(dplyr)
library(ggplot2)
library(sf)
library(raster)
library(exactextractr)
library(viridis)
# 2) Définition des indicateurs par pays
fake_indicators <- list(
"Senegal" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants","CDI", "NDVI", "NDBI"),
"Burkina" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants", "CDI", "NDVI", "NDBI")
)
# 3) Définition du chemin commun pour les shapefiles et rasters
chemin <- "../data"
# 4) Définition des chemins de shapefiles pour chaque pays
shapefiles <- list(
"Senegal" = list(
regions = file.path(chemin, "Senegal/Shapefiles_Optimises/regions.shp"),
departments = file.path(chemin, "Senegal/Shapefiles_Optimises/departments.shp"),
communes = file.path(chemin, "Senegal/Shapefiles_Optimises/communes.shp")
),
"Burkina" = list(
regions = file.path(chemin, "Burkina/Shapefiles_Optimises/regions.shp"),
departments = file.path(chemin, "Burkina/Shapefiles_Optimises/departments.shp"),
communes = file.path(chemin, "Burkina/Shapefiles_Optimises/communes.shp")
)
)
# 5) Fonction pour charger les données pour un pays donné
charger_donnees_pays <- function(pays) {
# Chargement des shapefiles
regions <- st_read(shapefiles[[pays]]$regions, quiet = TRUE)
departments <- st_read(shapefiles[[pays]]$departments, quiet = TRUE)
communes <- st_read(shapefiles[[pays]]$communes, quiet = TRUE)
# Chargement des rasters
raster_path <- file.path(chemin, pays, "Rasters")
mean_raster <- raster(file.path(raster_path, "malaria/mean_raster.tif"))
raster_nombre_malaria_enfants <- raster(file.path(raster_path, "malaria_enfants/raster_nombre_malaria_enfants.tif"))
raster_pop_enfants <- raster(file.path(raster_path, "malaria_enfants/raster_pop_enfants.tif"))
ndvi_raster <- raster(file.path(raster_path, paste0("Indices_spectraux/NDVI_", pays, ".tif")))
ndbi_raster <- raster(file.path(raster_path, paste0("Indices_spectraux/NDBI_", pays, ".tif")))
pop_resampled_binary <- raster(file.path(raster_path, "CDI/pop_resampled_binary.tif"))
mult_raster <- raster(file.path(raster_path, "CDI/mult_raster.tif"))
list(
regions = regions,
departments = departments,
communes = communes,
mean_raster = mean_raster,
raster_nombre_malaria_enfants = raster_nombre_malaria_enfants,
raster_pop_enfants = raster_pop_enfants,
ndvi_raster = ndvi_raster,
ndbi_raster = ndbi_raster,
pop_resampled_binary = pop_resampled_binary,
mult_raster = mult_raster
)
}
# 6) Calculs par niveau administratif
#    (Dans ce cas-ci, on suppose que les indicateurs sont déjà inclus ou calculés ailleurs.
#     Vous pouvez adapter si vous souhaitez calculer dynamiquement dans ce script.)
calculer_indicateurs <- function(donnees) {
# Les calculs sont supposés déjà faits et inclus dans les shapefiles optimisés.
# On renvoie simplement les données pour compatibilité.
list(
regions = donnees$regions,
departments = donnees$departments,
communes = donnees$communes,
mean_raster = donnees$mean_raster,
raster_nombre_malaria_enfants = donnees$raster_nombre_malaria_enfants,
raster_pop_enfants = donnees$raster_pop_enfants,
ndvi_raster = donnees$ndvi_raster,
ndbi_raster = donnees$ndbi_raster,
pop_resampled_binary = donnees$pop_resampled_binary,
mult_raster = donnees$mult_raster
)
}
# 7) Variables réactives pour stocker les données
data_global <- reactiveValues(
regions = NULL,
departments = NULL,
communes = NULL,
mean_raster = NULL,
raster_nombre_malaria_enfants = NULL,
raster_pop_enfants = NULL,
ndvi_raster = NULL,
ndbi_raster = NULL,
pop_resampled_binary = NULL,
mult_raster = NULL
)
# 8) Fonction pour mettre à jour les données globales
update_data_global <- function(pays) {
donnees <- charger_donnees_pays(pays)
resultats <- calculer_indicateurs(donnees)
data_global$regions <- resultats$regions
data_global$departments <- resultats$departments
data_global$communes <- resultats$communes
data_global$mean_raster <- resultats$mean_raster
data_global$raster_nombre_malaria_enfants <- resultats$raster_nombre_malaria_enfants
data_global$raster_pop_enfants <- resultats$raster_pop_enfants
data_global$ndvi_raster <- resultats$ndvi_raster
data_global$ndbi_raster <- resultats$ndbi_raster
data_global$pop_resampled_binary <- resultats$pop_resampled_binary
data_global$mult_raster <- resultats$mult_raster
message("✅ Données mises à jour pour le pays : ", pays)
}
donnee<- charger_donnees_pays("Senegal")
# ─────────────────────────────────────────────────────────────────────────────────
# global.R : Gestion des données multi-pays avec calculs et chargement des rasters
# Utilisation de shapefiles (.shp) et non de RDS
# ─────────────────────────────────────────────────────────────────────────────────
# 1) Chargement des bibliothèques nécessaires
library(shiny)
library(shinyjs)
library(leaflet)
library(dplyr)
library(ggplot2)
library(sf)
library(raster)
library(exactextractr)
library(viridis)
# 2) Définition des indicateurs par pays
fake_indicators <- list(
"Senegal" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants", "CDI", "NDVI", "NDBI"),
"Burkina" = c("Taux moyen de Paludisme", "Taux de malaria chez les enfants", "CDI", "NDVI", "NDBI")
)
# 3) Définition du chemin commun pour les shapefiles et rasters
chemin <- "../data"
# 4) Définition des chemins de shapefiles pour chaque pays
shapefiles <- list(
"Senegal" = list(
regions = file.path(chemin, "Senegal/Shapefiles_Optimises/regions.shp"),
departments = file.path(chemin, "Senegal/Shapefiles_Optimises/departments.shp"),
communes = file.path(chemin, "Senegal/Shapefiles_Optimises/communes.shp")
),
"Burkina" = list(
regions = file.path(chemin, "Burkina/Shapefiles_Optimises/regions.shp"),
departments = file.path(chemin, "Burkina/Shapefiles_Optimises/departments.shp"),
communes = file.path(chemin, "Burkina/Shapefiles_Optimises/communes.shp")
)
)
# 5) Fonction pour charger les données pour un pays donné
charger_donnees_pays <- function(pays) {
# Vérification de l'existence des shapefiles
required_shapefiles <- shapefiles[[pays]]
missing_shapefiles <- required_shapefiles[!file.exists(unlist(required_shapefiles))]
if (length(missing_shapefiles) > 0) {
stop("Erreur : Les shapefiles suivants manquent pour le pays ", pays, " : ",
paste(names(missing_shapefiles), collapse = ", "))
}
# Chargement des shapefiles
regions <- st_read(shapefiles[[pays]]$regions, quiet = TRUE)
departments <- st_read(shapefiles[[pays]]$departments, quiet = TRUE)
communes <- st_read(shapefiles[[pays]]$communes, quiet = TRUE)
# Chargement des rasters
raster_path <- file.path(chemin, pays, "Rasters")
# Définition des chemins des rasters
raster_files <- list(
mean_raster = file.path(raster_path, "malaria/mean_raster.tif"),
raster_nombre_malaria_enfants = file.path(raster_path, "malaria_enfants/raster_nombre_malaria_enfants.tif"),
raster_pop_enfants = file.path(raster_path, "malaria_enfants/raster_pop_enfants.tif"),
ndvi_raster = file.path(raster_path, paste0("Indices_spectraux/NDVI_", pays, ".tif")),
ndbi_raster = file.path(raster_path, paste0("Indices_spectraux/NDBI_", pays, ".tif")),
pop_resampled_binary = file.path(raster_path, "CDI/pop_resampled_binary.tif"),
mult_raster = file.path(raster_path, "CDI/mult_raster.tif")
)
# Vérification de l'existence des rasters
missing_rasters <- raster_files[!file.exists(unlist(raster_files))]
if (length(missing_rasters) > 0) {
stop("Erreur : Les fichiers rasters suivants manquent pour le pays ", pays, " : ",
paste(names(missing_rasters), collapse = ", "))
}
# Chargement des rasters
mean_raster <- raster(raster_files$mean_raster)
raster_nombre_malaria_enfants <- raster(raster_files$raster_nombre_malaria_enfants)
raster_pop_enfants <- raster(raster_files$raster_pop_enfants)
ndvi_raster <- raster(raster_files$ndvi_raster)
ndbi_raster <- raster(raster_files$ndbi_raster)
pop_resampled_binary <- raster(raster_files$pop_resampled_binary)
mult_raster <- raster(raster_files$mult_raster)
list(
regions = regions,
departments = departments,
communes = communes,
mean_raster = mean_raster,
raster_nombre_malaria_enfants = raster_nombre_malaria_enfants,
raster_pop_enfants = raster_pop_enfants,
ndvi_raster = ndvi_raster,
ndbi_raster = ndbi_raster,
pop_resampled_binary = pop_resampled_binary,
mult_raster = mult_raster
)
}
# 6) Calculs par niveau administratif
#    (Les indicateurs sont supposés déjà calculés et inclus dans les shapefiles optimisés)
calculer_indicateurs <- function(donnees) {
list(
regions = donnees$regions,
departments = donnees$departments,
communes = donnees$communes,
mean_raster = donnees$mean_raster,
raster_nombre_malaria_enfants = donnees$raster_nombre_malaria_enfants,
raster_pop_enfants = donnees$raster_pop_enfants,
ndvi_raster = donnees$ndvi_raster,
ndbi_raster = donnees$ndbi_raster,
pop_resampled_binary = donnees$pop_resampled_binary,
mult_raster = donnees$mult_raster
)
}
# 7) Variables réactives pour stocker les données
data_global <- reactiveValues(
regions = NULL,
departments = NULL,
communes = NULL,
mean_raster = NULL,
raster_nombre_malaria_enfants = NULL,
raster_pop_enfants = NULL,
ndvi_raster = NULL,
ndbi_raster = NULL,
pop_resampled_binary = NULL,
mult_raster = NULL
)
# 8) Fonction pour mettre à jour les données globales
update_data_global <- function(pays) {
donnees <- charger_donnees_pays(pays)
resultats <- calculer_indicateurs(donnees)
data_global$regions <- resultats$regions
data_global$departments <- resultats$departments
data_global$communes <- resultats$communes
data_global$mean_raster <- resultats$mean_raster
data_global$raster_nombre_malaria_enfants <- resultats$raster_nombre_malaria_enfants
data_global$raster_pop_enfants <- resultats$raster_pop_enfants
data_global$ndvi_raster <- resultats$ndvi_raster
data_global$ndbi_raster <- resultats$ndbi_raster
data_global$pop_resampled_binary <- resultats$pop_resampled_binary
data_global$mult_raster <- resultats$mult_raster
message("✅ Données mises à jour pour le pays : ", pays)
}
runApp('Scripts R KD/app_KD.R')
a<- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles_Optimises/regions.shp"
a<- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles_Optimises/regions.shp"
a<- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles_Optimises/regions.shp")
View(a)
b<- st_read("C:/Users/HP/OneDrive/Documents/GitHub/Projet_Final_Stat_Spatiale/data/Senegal/Shapefiles_Optimises/departments.shp")
View(a)
>>>>>>> e7b538d15b75fbe8b405662523339d8f892cf9d1
runApp('Scripts R KD/app_KD.R')
